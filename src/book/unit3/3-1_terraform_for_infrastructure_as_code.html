<div class="topic-content">
    <header class="topic-header" aria-label="Header">
        <h1 class="topic-title">Unit 3.1: Terraform for Infrastructure as Code</h1>
        <p class="topic-intro"><strong>Infrastructure as Code (IaC)</strong> is a foundational DevOps practice that involves managing and provisioning infrastructure through machine-readable definition files, rather than manual configuration. <a href="https://www.terraform.io/" target="_blank">Terraform</a> by HashiCorp is the industry-standard tool for IaC, allowing you to declaratively define, version, and automate your cloud and on-premise resources.</p>
    </header>


    <section>
        <!-- HCL Syntax -->
        <h2><i class="bi bi-file-code"></i> 1. Deep Dive into HCL Syntax</h2>
        <p>
            Terraform configurations are written in <strong>HashiCorp Configuration Language (HCL)</strong>. HCL is designed to be human-readable and machine-friendly. A Terraform configuration consists of several key blocks.
        </p>

        <h4>Core Terraform Blocks</h4>
        <pre><code class="language-hcl">
# 1. The `terraform` block configures Terraform itself, including required providers.
terraform {
  required_providers {
    aws = {
      source  = &quot;hashicorp/aws&quot;
      version = &quot;~&gt; 5.0&quot;
    }
  }
}

# 2. The `provider` block configures a specific provider (e.g., AWS credentials and region).
provider &quot;aws&quot; {
  region = &quot;us-east-1&quot;
}

# 3. The `resource` block defines a piece of infrastructure.
# Format: resource &quot;&lt;PROVIDER&gt;_&lt;TYPE&gt;&quot; &quot;&lt;LOCAL_NAME&gt;&quot; { ... }
resource &quot;aws_s3_bucket&quot; &quot;app_storage&quot; {
  bucket = &quot;my-unique-app-storage-bucket-12345&quot;

  tags = {
    Name        = &quot;My App Storage&quot;
    Environment = &quot;Dev&quot;
  }
}

# 4. The `variable` block defines an input variable.
variable &quot;bucket_prefix&quot; {
  description = &quot;Prefix for the S3 bucket name.&quot;
  type        = string
  default     = &quot;app-storage&quot;
}

# 5. The `output` block defines an output value from your configuration.
output &quot;bucket_id&quot; {
  description = &quot;The ID (name) of the created S3 bucket.&quot;
  value       = aws_s3_bucket.app_storage.id
}
    </code></pre>

        <div class="text-center my-4">
            <pre class="mermaid">
  <script type="text/plain">
    graph LR
                A["Terraform Core"] --> B{"terraform init"};
                B -- "Downloads Provider" --> C["AWS Provider"];
                B --> D["Terraform Plan/Apply"];
                D -- "Reads" --> E["main.tf (HCL Code)"];
                E -- "Defines" --> F["Resource: aws_s3_bucket"];
                D -- "Creates/Updates" --> G["AWS API"];
                G -- "Provisions" --> H["S3 Bucket in AWS"];
  </script>
</pre>
            <small class="text-muted">Diagram: The Basic Terraform Workflow (init, plan, apply)</small>
        </div>
    </section>

    <section>
        <!-- Remote State -->
        <h2><i class="bi bi-cloud-arrow-up"></i> 2. Managing Remote State</h2>
        <p>
            Terraform must store state about your managed infrastructure to map real-world resources to your configuration. By default, this state is stored in a local file named <code>terraform.tfstate</code>. <strong>This is dangerous for teams.</strong> If multiple people run Terraform at the same time, or if someone loses their state file, your infrastructure can be corrupted.
        </p>
        <p>
            The solution is <strong>remote state</strong>, where the state file is stored in a shared, remote location. A best practice for AWS is to use an S3 bucket for storage and a DynamoDB table for <strong>state locking</strong>, which prevents concurrent executions.
        </p>

        <div class="text-center my-4">
            <pre class="mermaid">
  <script type="text/plain">
    graph TD
                subgraph "Developer A"
                    A1["terraform apply"] -- "Tries to acquire lock" --> DDB[DynamoDB Lock Table];
                end
                subgraph "Developer B"
                    B1["terraform apply"] -- "Tries to acquire lock" --> DDB;
                end

                DDB -- "Grants lock to A" --> A1;
                DDB -- "Denies lock to B (fails)" --> B1;

                A1 -- "Writes state on success" --> S3["S3 Bucket (terraform.tfstate)"];

                style DDB fill:#f9d6d5,stroke:#333,stroke-width:2px
  </script>
</pre>
            <small class="text-muted">Diagram: Remote State and Locking with S3 and DynamoDB</small>
        </div>

        <h4>Configuration for Remote State</h4>
        <p>You configure the remote backend in your <code>terraform</code> block.</p>
        <pre><code class="language-hcl">
# terraform.tf
terraform {
  backend &quot;s3&quot; {
    bucket         = &quot;my-terraform-state-bucket&quot; # Must be created manually and be unique
    key            = &quot;global/s3/terraform.tfstate&quot; # Path to state file in the bucket
    region         = &quot;us-east-1&quot;
    dynamodb_table = &quot;terraform-state-locks&quot;   # Must be created manually
    encrypt        = true
  }
  # ... required_providers ...
}
    </code></pre>
        <div class="info-box">You must create the S3 bucket and DynamoDB table manually before you can initialize this backend. This is a one-time setup task for your organization.</div>
    </section>

    <section>
        <!-- Modules -->
        <h2><i class="bi bi-box-seam"></i> 3. Creating Reusable Modules</h2>
        <p>
            As your infrastructure grows, you'll want to reuse common patterns. <strong>Terraform Modules</strong> are the primary way to package and reuse resource configurations. A module is a self-contained set of Terraform configuration files in a directory.
        </p>

        <h4>Example: An S3 Bucket Module</h4>
        <p>Let's create a module for a standardized S3 bucket with versioning and tagging.</p>
        <p>Project Structure:</p>
        <pre><code>
.
├── modules
│   └── s3-bucket
│       ├── main.tf
│       ├── variables.tf
│       └── outputs.tf
└── main.tf
    </code></pre>

        <p><code>modules/s3-bucket/variables.tf</code></p>
        <pre><code class="language-hcl">
variable &quot;bucket_name&quot; {
  description = &quot;The name of the S3 bucket.&quot;
  type        = string
}

variable &quot;tags&quot; {
  description = &quot;A map of tags to assign to the bucket.&quot;
  type        = map(string)
  default     = {}
}
    </code></pre>

        <p><code>modules/s3-bucket/main.tf</code></p>
        <pre><code class="language-hcl">
resource &quot;aws_s3_bucket&quot; &quot;this&quot; {
  bucket = var.bucket_name
  tags   = var.tags
}

resource &quot;aws_s3_bucket_versioning&quot; &quot;this&quot; {
  bucket = aws_s3_bucket.this.id
  versioning_configuration {
    status = &quot;Enabled&quot;
  }
}
    </code></pre>

        <p><code>modules/s3-bucket/outputs.tf</code></p>
        <pre><code class="language-hcl">
output &quot;bucket_arn&quot; {
  description = &quot;The ARN of the bucket.&quot;
  value       = aws_s3_bucket.this.arn
}
    </code></pre>

        <h4>Using the Module</h4>
        <p>Now, you can use this module in your root <code>main.tf</code>.</p>
        <pre><code class="language-hcl">
# main.tf
module &quot;app_storage&quot; {
  source = &quot;./modules/s3-bucket&quot;

  bucket_name = &quot;my-app-storage-from-module&quot;
  tags = {
    Environment = &quot;Production&quot;
    ManagedBy   = &quot;Terraform&quot;
  }
}

output &quot;app_storage_arn&quot; {
  value = module.app_storage.bucket_arn
}
    </code></pre>
    </section>

    <section>
        <!-- Provisioning Kubernetes -->
        <h2><i class="bi bi-grid-3x3-gap"></i> 4. Provisioning Kubernetes and Cloud Resources (AWS)</h2>
        <p>
            Terraform is not just for basic resources; it excels at provisioning complex systems like Kubernetes clusters. While a full EKS (Elastic Kubernetes Service) cluster is complex, the principle is the same: you define resources and their relationships.
        </p>
        <p>
            The <a href="https://registry.terraform.io/modules/terraform-aws-modules/eks/aws/latest" target="_blank">official AWS EKS module</a> is a powerful, community-supported module that abstracts away most of the complexity of setting up a production-ready cluster.
        </p>
        <p>Once a cluster is provisioned, Terraform can also manage resources inside it using the <a href="https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs" target="_blank">Kubernetes Provider</a> and the <a href="https://registry.terraform.io/providers/hashicorp/helm/latest/docs" target="_blank">Helm Provider</a>. This allows you to define your infrastructure and your application deployments in the same IaC workflow, which we will explore in the next topic.
        </p>
    </section>
</div>