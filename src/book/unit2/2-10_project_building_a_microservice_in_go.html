<div class="topic-content">
    <header class="topic-header" aria-label="Header">
        <h1 class="topic-title">Unit 2.10: Project - Building a Microservice in Go</h1>
    </header>

    <section>
        <p>In this hands-on project, we will build a complete <strong>Order Microservice</strong> in Go. We will use Gin for the API, GORM for database interaction, and implement structured logging, background processing with goroutines, and robust testing strategies.</p>



        <h2>Project Goal</h2>
        <p>
            To create a RESTful API for managing orders. The service will allow creating new orders and retrieving their details. Upon creation, the order will be passed to a background worker for asynchronous processing. This project will demonstrate core Go backend concepts in a practical, cloud-native context.
        </p>

        <h3>Key Concepts Integrated:</h3>
        <ul>
            <li><strong>Project Structure:</strong> A standard Go project layout (<code>/cmd</code>, <code>/internal</code>).</li>
            <li><strong>Gin Framework:</strong> Building the RESTful API and handling requests.</li>
            <li><strong>GORM:</strong> Object-Relational Mapping (ORM) for PostgreSQL.</li>
            <li><strong>Concurrency:</strong> Using goroutines and channels for a simple background worker pattern.</li>
            <li><strong>Structured Logging:</strong> Using the standard library's <code>slog</code> package.</li>
            <li><strong>Testing:</strong> Unit testing with interface-based mocking and integration testing with Testcontainers.</li>
            <li><strong>Containerization:</strong> A multi-stage Dockerfile for a minimal, secure production image.</li>
        </ul>
        <h2>1. Project Setup</h2>
        <p>Start by creating the project directory and initializing a Go module.</p>
        <pre><code class="language-bash">
mkdir order-service
cd order-service
go mod init example.com/order-service
    </code></pre>
        <p>Create the standard directory structure:</p>
        <pre><code class="language-bash">
mkdir -p cmd/server internal/database internal/service
    </code></pre>
        <p>Install the necessary dependencies:</p>
        <pre><code class="language-bash">
go get -u github.com/gin-gonic/gin
go get -u gorm.io/gorm
go get -u gorm.io/driver/postgres
go get -u github.com/google/uuid
# For testing
go get -u github.com/stretchr/testify/assert
go get -u github.com/testcontainers/testcontainers-go/modules/postgres
    </code></pre>



        <h2>2. Database and GORM Model</h2>
        <h4><code>internal/database/database.go</code></h4>
        <p>This file will contain our GORM model and database connection logic.</p>
        <pre><code class="language-go">
package database

import (
    &quot;gorm.io/driver/postgres&quot;
    &quot;gorm.io/gorm&quot;
)

// Order represents an order in the database
type Order struct {
    gorm.Model // Includes ID, CreatedAt, UpdatedAt, DeletedAt
    Product  string
    Quantity int
    Status   string
}

// NewConnection creates a new database connection
func NewConnection(dsn string) (*gorm.DB, error) {
    db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
    if err != nil {
        return nil, err
    }

    // Migrate the schema
    if err := db.AutoMigrate(&amp;Order{}); err != nil {
        return nil, err
    }
    return db, nil
}
    </code></pre>



        <h2>3. Service Layer with Background Worker</h2>
        <h4><code>internal/service/order_service.go</code></h4>
        <p>This layer contains the business logic. It will interact with the database and send created orders to a channel for a background worker to process.</p>
        <pre><code class="language-go">
package service

import (
    &quot;log/slog&quot;
    &quot;time&quot;

    &quot;example.com/order-service/internal/database&quot;
    &quot;gorm.io/gorm&quot;
)

// OrderService handles the business logic for orders.
type OrderService struct {
    db         *gorm.DB
    orderQueue chan uint // Channel to send order IDs for processing
}

// NewOrderService creates a new OrderService and starts the background worker.
func NewOrderService(db *gorm.DB) *OrderService {
    s := &amp;OrderService{
        db:         db,
        orderQueue: make(chan uint, 100), // Buffered channel
    }
    go s.processOrders() // Start the background worker
    return s
}

// CreateOrder creates a new order and queues it for processing.
func (s *OrderService) CreateOrder(product string, quantity int) (*database.Order, error) {
    order := &amp;database.Order{
        Product:  product,
        Quantity: quantity,
        Status:   &quot;PENDING&quot;,
    }

    if result := s.db.Create(order); result.Error != nil {
        return nil, result.Error
    }

    // Send the order ID to the processing queue
    s.orderQueue &lt;- order.ID
    slog.Info(&quot;Order queued for processing&quot;, &quot;order_id&quot;, order.ID)

    return order, nil
}

// GetOrder retrieves an order by its ID.
func (s *OrderService) GetOrder(id uint) (*database.Order, error) {
    var order database.Order
    if result := s.db.First(&amp;order, id); result.Error != nil {
        return nil, result.Error
    }
    return &amp;order, nil
}

// processOrders is the background worker that processes orders from the queue.
func (s *OrderService) processOrders() {
    for orderID := range s.orderQueue {
        slog.Info(&quot;Processing order...&quot;, &quot;order_id&quot;, orderID)
        time.Sleep(2 * time.Second) // Simulate work

        s.db.Model(&amp;database.Order{}).Where(&quot;id = ?&quot;, orderID).Update(&quot;status&quot;, &quot;PROCESSED&quot;)
        slog.Info(&quot;Order processed successfully&quot;, &quot;order_id&quot;, orderID)
    }
}
    </code></pre>



        <h2>4. API Layer (Gin Handlers)</h2>
        <h4><code>cmd/server/main.go</code></h4>
        <p>This is the entry point of our application. It sets up the Gin router, database connection, service, and handlers.</p>
        <pre><code class="language-go">
package main

import (
    &quot;log&quot;
    &quot;log/slog&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;strconv&quot;

    &quot;example.com/order-service/internal/database&quot;
    &quot;example.com/order-service/internal/service&quot;
    &quot;github.com/gin-gonic/gin&quot;
)

func main() {
    // Setup structured logger
    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
    slog.SetDefault(logger)

    // Database connection
    dsn := &quot;host=localhost user=gorm password=gorm dbname=gorm port=5432 sslmode=disable&quot;
    db, err := database.NewConnection(dsn)
    if err != nil {
        log.Fatalf(&quot;Failed to connect to database: %v&quot;, err)
    }

    // Setup service
    orderService := service.NewOrderService(db)

    // Setup Gin router
    r := gin.Default()

    r.POST(&quot;/orders&quot;, func(c *gin.Context) {
        var json struct {
            Product  string `json:&quot;product&quot;`
            Quantity int    `json:&quot;quantity&quot;`
        }
        if err := c.ShouldBindJSON(&amp;json); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
            return
        }

        order, err := orderService.CreateOrder(json.Product, json.Quantity)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;Failed to create order&quot;})
            return
        }
        c.JSON(http.StatusCreated, order)
    })

    r.GET(&quot;/orders/:id&quot;, func(c *gin.Context) {
        id, err := strconv.ParseUint(c.Param(&quot;id&quot;), 10, 32)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;Invalid order ID&quot;})
            return
        }

        order, err := orderService.GetOrder(uint(id))
        if err != nil {
            c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;Order not found&quot;})
            return
        }
        c.JSON(http.StatusOK, order)
    })

    slog.Info(&quot;Starting server on port 8080&quot;)
    r.Run(&quot;:8080&quot;)
}
    </code></pre>



        <h2>5. Testing</h2>
        <p>We will write an integration test for our API using Testcontainers to ensure it works with a real PostgreSQL database.</p>
        <h4><code>cmd/server/main_test.go</code></h4>
        <pre><code class="language-go">
package main

import (
    &quot;bytes&quot;
    &quot;context&quot;
    &quot;encoding/json&quot;
    &quot;net/http&quot;
    &quot;net/http/httptest&quot;
    &quot;testing&quot;

    &quot;example.com/order-service/internal/database&quot;
    &quot;example.com/order-service/internal/service&quot;
    &quot;github.com/gin-gonic/gin&quot;
    &quot;github.com/stretchr/testify/assert&quot;
    &quot;github.com/testcontainers/testcontainers-go&quot;
    &quot;github.com/testcontainers/testcontainers-go/modules/postgres&quot;
    &quot;github.com/testcontainers/testcontainers-go/wait&quot;
)

func setupRouter(db *gorm.DB) *gin.Engine {
    // This function is a simplified version of main() for testing
    orderService := service.NewOrderService(db)
    r := gin.Default()

    r.POST(&quot;/orders&quot;, func(c *gin.Context) {
        // ... handler logic from main ...
    })
    r.GET(&quot;/orders/:id&quot;, func(c *gin.Context) {
        // ... handler logic from main ...
    })
    return r
}

func TestOrderAPI_Integration(t *testing.T) {
    ctx := context.Background()

    // Start a PostgreSQL container
    pgContainer, err := postgres.RunContainer(ctx,
        testcontainers.WithImage(&quot;postgres:15-alpine&quot;),
        postgres.WithDatabase(&quot;test-db&quot;),
        postgres.WithUsername(&quot;user&quot;),
        postgres.WithPassword(&quot;password&quot;),
        wait.ForLog(&quot;database system is ready to accept connections&quot;),
    )
    if err != nil {
        t.Fatalf(&quot;failed to start container: %s&quot;, err)
    }
    defer pgContainer.Terminate(ctx)

    // Get connection string and connect
    connStr, err := pgContainer.ConnectionString(ctx, &quot;sslmode=disable&quot;)
    assert.NoError(t, err)
    db, err := database.NewConnection(connStr)
    assert.NoError(t, err)

    router := setupRouter(db)

    // Test POST /orders
    orderPayload := `{&quot;product&quot;:&quot;Laptop&quot;,&quot;quantity&quot;:1}`
    w := httptest.NewRecorder()
    req, _ := http.NewRequest(&quot;POST&quot;, &quot;/orders&quot;, bytes.NewBufferString(orderPayload))
    req.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
    router.ServeHTTP(w, req)

    assert.Equal(t, http.StatusCreated, w.Code)

    var createdOrder database.Order
    json.Unmarshal(w.Body.Bytes(), &amp;createdOrder)
    assert.Equal(t, &quot;Laptop&quot;, createdOrder.Product)
    assert.Equal(t, 1, createdOrder.Quantity)
    assert.Equal(t, &quot;PENDING&quot;, createdOrder.Status)

    // Test GET /orders/:id
    w = httptest.NewRecorder()
    req, _ = http.NewRequest(&quot;GET&quot;, fmt.Sprintf(&quot;/orders/%d&quot;, createdOrder.ID), nil)
    router.ServeHTTP(w, req)

    assert.Equal(t, http.StatusOK, w.Code)
    var fetchedOrder database.Order
    json.Unmarshal(w.Body.Bytes(), &amp;fetchedOrder)
    assert.Equal(t, createdOrder.ID, fetchedOrder.ID)
    assert.Equal(t, &quot;Laptop&quot;, fetchedOrder.Product)
}
    </code></pre>



        <h2>6. Containerization &amp; Running</h2>
        <h4><code>Dockerfile</code></h4>
        <p>A multi-stage Dockerfile to create a minimal production image.</p>
        <pre><code class="language-dockerfile">
# Stage 1: Builder
FROM golang:1.22-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o /server ./cmd/server

# Stage 2: Final Image
FROM scratch
COPY --from=builder /server /server
EXPOSE 8080
ENTRYPOINT [&quot;/server&quot;]
    </code></pre>

        <h4><code>docker-compose.yml</code></h4>
        <p>To run the service and its PostgreSQL dependency together.</p>
        <pre><code class="language-yaml">
version: &#x27;3.8&#x27;
services:
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: gorm
      POSTGRES_PASSWORD: gorm
      POSTGRES_DB: gorm
    ports:
      - &quot;5432:5432&quot;

  app:
    build: .
    ports:
      - &quot;8080:8080&quot;
    environment:
      GIN_MODE: release
      DB_DSN: &quot;host=db user=gorm password=gorm dbname=gorm port=5432 sslmode=disable&quot;
    depends_on:
      - db
    </code></pre>

        <p>Run the entire stack with:</p>
        <pre><code class="language-bash">docker compose up --build</code></pre>
    </section>
</div>