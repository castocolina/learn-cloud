<div class="topic-content">
    <header class="topic-header" aria-label="Header">
        <h1 class="topic-title">Unit 2.7: Advanced Backend Topics</h1>
    </header>

    <section>
        <h2><i class="bi bi-lightning-charge"></i> 1. Event-Driven Architecture with Message Queues</h2>
        <p>
            <strong>Event-driven architecture (EDA)</strong> is a powerful paradigm where services communicate asynchronously by producing and consuming events. This decouples services, allowing them to evolve and scale independently. The central component of this architecture is a <strong>message queue</strong> (or message broker).
        </p>

        <div class="text-center my-4">
            <pre class="mermaid">
  <script type="text/plain">
    graph TD
                Producer["Service A (Producer)"] -- "Publishes Event" --> MessageQueue["Message Queue"];
                MessageQueue -- "Delivers Event" --> Consumer1["Service B (Consumer)"];
                MessageQueue -- "Delivers Event" --> Consumer2["Service C (Consumer)"];
  </script>
</pre>
            <small class="text-muted">Diagram: Asynchronous Communication in an Event-Driven Architecture</small>
        </div>

        <h3>RabbitMQ with Go</h3>
        <p>
            <a href="https://www.rabbitmq.com/" target="_blank">RabbitMQ</a> is a mature and widely used message broker. The official Go client library is robust and provides all the features needed to interact with it.
        </p>

        <h4>Setup: Running RabbitMQ with Docker</h4>
        <pre><code class="language-bash">
docker run -d --hostname my-rabbit --name some-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management-alpine
    </code></pre>
        <p>The management UI is available at <a href="http://localhost:15672" target="_blank">http://localhost:15672</a> (user: `guest`, pass: `guest`).</p>

        <h4>Go Client Installation</h4>
        <pre><code class="language-bash">go get github.com/rabbitmq/amqp091-go</code></pre>

        <h4>Producer Example (<code>producer/main.go</code>)</h4>
        <p>This program will connect to RabbitMQ and send a message every second.</p>
        <pre><code class="language-go">
package main

import (
    &quot;context&quot;
    &quot;log&quot;
    &quot;time&quot;

    amqp &quot;github.com/rabbitmq/amqp091-go&quot;
)

func failOnError(err error, msg string) {
    if err != nil {
        log.Panicf(&quot;%s: %s&quot;, msg, err)
    }
}

func main() {
    conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
    failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
    defer conn.Close()

    ch, err := conn.Channel()
    failOnError(err, &quot;Failed to open a channel&quot;)
    defer ch.Close()

    q, err := ch.QueueDeclare(
        &quot;task_queue&quot;, // name
        true,         // durable
        false,        // delete when unused
        false,        // exclusive
        false,        // no-wait
        nil,          // arguments
    )
    failOnError(err, &quot;Failed to declare a queue&quot;)

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    body := &quot;Hello, this is a task!&quot;
    err = ch.PublishWithContext(ctx,
        &quot;&quot;,           // exchange
        q.Name,       // routing key
        false,        // mandatory
        false,        // immediate
        amqp.Publishing{
            DeliveryMode: amqp.Persistent,
            ContentType:  &quot;text/plain&quot;,
            Body:         []byte(body),
        })
    failOnError(err, &quot;Failed to publish a message&quot;)
    log.Printf(&quot; [x] Sent %s\n&quot;, body)
}
    </code></pre>

        <h4>Consumer Example (<code>consumer /main.go</code>)</h4>
        <p>This program will connect to the same queue and process messages as they arrive.</p>
        <pre><code class="language-go">
package main

import (
    &quot;log&quot;

    amqp &quot;github.com/rabbitmq/amqp091-go&quot;
)

func failOnError(err error, msg string) {
    if err != nil {
        log.Panicf(&quot;%s: %s&quot;, msg, err)
    }
}

func main() {
    conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)
    failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)
    defer conn.Close()

    ch, err := conn.Channel()
    failOnError(err, &quot;Failed to open a channel&quot;)
    defer ch.Close()

    q, err := ch.QueueDeclare(
        &quot;task_queue&quot;, // name
        true,         // durable
        false,        // delete when unused
        false,        // exclusive
        false,        // no-wait
        nil,          // arguments
    )
    failOnError(err, &quot;Failed to declare a queue&quot;)

    msgs, err := ch.Consume(
        q.Name, // queue
        &quot;&quot;,     // consumer
        true,   // auto-ack
        false,  // exclusive
        false,  // no-local
        false,  // no-wait
        nil,    // args
    )
    failOnError(err, &quot;Failed to register a consumer&quot;)

    var forever chan struct{}

    go func() {
        for d := range msgs {
            log.Printf(&quot;Received a message: %s&quot;, d.Body)
        }
    }()

    log.Printf(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;)
    &lt;-forever
}
    </code></pre>



        <!-- gRPC -->
        <h2><i class="bi bi-braces-asterisk"></i> 2. Working with Protobuf for gRPC Communication</h2>
        <p>
            For high-performance, low-latency internal communication between microservices, <strong>gRPC</strong> is often preferred over REST. It uses HTTP/2 for transport and <strong>Protocol Buffers (Protobuf)</strong> as its interface definition language (IDL), enabling efficient binary serialization and strongly-typed contracts.
        </p>

        <div class="text-center my-4">
            <pre class="mermaid">
  <script type="text/plain">
    graph TD
                A["Client Application"] --> B["Client Stub (Generated)"];
                B -- "RPC Call (Binary Protobuf)" --> C["Network (HTTP/2)"];
                C --> D["Server (Generated Skeleton)"];
                D --> E["Service Implementation"];
                E -- "Response (Binary Protobuf)" --> D;
                D --> C;
                C --> B;
                B --> A;
  </script>
</pre>
            <small class="text-muted">Diagram: gRPC Communication Flow</small>
        </div>

        <h3>Protocol Buffers (Protobuf)</h3>
        <p>
            You define your services and message structures in a <code>.proto</code> file. This file is a language-agnostic contract that can be used to generate client and server code in any supported language, including Go.
        </p>

        <h4>Example <code>.proto</code> file (<code>proto/greeter.proto</code>)</h4>
        <pre><code class="language-protobuf">
syntax = &quot;proto3&quot;;

package greeter;

option go_package = &quot;example.com/my-go-service/proto&quot;;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user&#x27;s name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
    </code></pre>

        <h4>Compiling Protobuf to Go</h4>
        <p>First, install the `protoc` compiler and the Go plugins:</p>
        <pre><code class="language-bash">
# Install protoc (e.g., on macOS: brew install protobuf)

# Install the Go plugins
go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2

# Ensure your PATH includes the Go bin directory
export PATH=&quot;$PATH:$(go env GOPATH)/bin&quot;
    </code></pre>
        <p>Then, compile your <code>.proto</code> file:</p>
        <pre><code class="language-bash">
protoc --go_out=. --go_opt=paths=source_relative \
    --go-grpc_out=. --go-grpc_opt=paths=source_relative \
    proto/greeter.proto
    </code></pre>
        <p>This generates <code>greeter.pb.go</code> and <code>greeter_grpc.pb.go</code> inside the `proto` directory.</p>

        <h4>gRPC Server Example (<code>server /main.go</code>)</h4>
        <pre><code class="language-go">
package main

import (
    &quot;context&quot;
    &quot;log&quot;
    &quot;net&quot;

    pb &quot;example.com/my-go-service/proto&quot; // Import generated code
    &quot;google.golang.org/grpc&quot;
)

// server is used to implement greeter.GreeterServer.
type server struct {
    pb.UnimplementedGreeterServer
}

// SayHello implements greeter.GreeterServer
func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
    log.Printf(&quot;Received: %v&quot;, in.GetName())
    return &amp;pb.HelloReply{Message: &quot;Hello &quot; + in.GetName()}, nil
}

func main() {
    lis, err := net.Listen(&quot;tcp&quot;, &quot;:50051&quot;)
    if err != nil {
        log.Fatalf(&quot;failed to listen: %v&quot;, err)
    }
    s := grpc.NewServer()
    pb.RegisterGreeterServer(s, &amp;server{})
    log.Printf(&quot;server listening at %v&quot;, lis.Addr())
    if err := s.Serve(lis); err != nil {
        log.Fatalf(&quot;failed to serve: %v&quot;, err)
    }
}
    </code></pre>

        <h4>gRPC Client Example (<code>client /main.go</code>)</h4>
        <pre><code class="language-go">
package main

import (
    &quot;context&quot;
    &quot;log&quot;
    &quot;os&quot;
    &quot;time&quot;

    pb &quot;example.com/my-go-service/proto&quot;
    &quot;google.golang.org/grpc&quot;
    &quot;google.golang.org/grpc/credentials/insecure&quot;
)

func main() {
    conn, err := grpc.Dial(&quot;localhost:50051&quot;, grpc.WithTransportCredentials(insecure.NewCredentials()))
    if err != nil {
        log.Fatalf(&quot;did not connect: %v&quot;, err)
    }
    defer conn.Close()
    c := pb.NewGreeterClient(conn)

    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel()

    name := &quot;world&quot;
    if len(os.Args) &gt; 1 {
        name = os.Args[1]
    }

    r, err := c.SayHello(ctx, &amp;pb.HelloRequest{Name: name})
    if err != nil {
        log.Fatalf(&quot;could not greet: %v&quot;, err)
    }
    log.Printf(&quot;Greeting: %s&quot;, r.GetMessage())
}
    </code></pre>
    </section>
</div>