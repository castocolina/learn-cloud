<div class="topic-content">
    <header class="topic-header" aria-label="Header">
        <h1 class="topic-title">Unit 2.3: Concurrency: The Go Philosophy</h1>
    </header>

    <section>
        <p><strong>Go's Concurrency Proverb:</strong> "Do not communicate by sharing memory; instead, share memory by communicating."</p>

        <p>This philosophy encourages you to pass data between concurrent processes (goroutines) through channels, rather than having multiple processes compete for access to the same piece of memory using locks. This approach helps prevent entire classes of common concurrency bugs.</p>



        <!-- Goroutines -->
        <h2><i class="bi bi-cpu"></i> 1. Goroutines: Concurrency Made Easy</h2>
        <p>
            A <strong>goroutine</strong> is a lightweight thread of execution managed by the Go runtime. They are incredibly cheap to createâ€”you can have hundreds of thousands or even millions of them running in a single process. Creating a goroutine is as simple as prefixing a function call with the <code>go</code> keyword.
        </p>

        <pre><code class="language-go">
package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func say(s string) {
    for i := 0; i &lt; 3; i++ {
        fmt.Println(s)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // Start a new goroutine
    go say(&quot;world&quot;)

    // The main function continues executing in its own goroutine
    say(&quot;hello&quot;)
}

// Possible Output:
// hello
// world
// world
// hello
// hello
// world
    </code></pre>
        <p>When you run this code, you'll see the output from both calls to `say` interleaved. This is because the `go say("world")` call starts a new goroutine that runs concurrently with the `main` goroutine. If we didn't have the `say("hello")` call, the main function would exit immediately, and the "world" goroutine might not have a chance to run at all. This demonstrates the need for synchronization.</p>



        <!-- Channels -->
        <h2><i class="bi bi-arrows-left-right"></i> 2. Channels: Synchronizing and Communicating</h2>
        <p>
            <strong>Channels</strong> are the pipes that connect concurrent goroutines. You can send values into channels from one goroutine and receive those values into another. They are typed, meaning a channel can only transport data of a specific type.
        </p>

        <pre><code class="language-go">
// Create a new channel of type string
ch := make(chan string)

// Send a value into the channel
ch &lt;- &quot;hello&quot;

// Receive a value from the channel
msg := &lt;-ch
    </code></pre>

        <p>By default, sends and receives on a channel are <strong>blocking</strong>. This is the key to synchronization. A sender will block until a receiver is ready, and a receiver will block until a sender sends a value. Let's use a channel to fix our previous example.</p>

        <pre><code class="language-go">
package main

import &quot;fmt&quot;

func sum(s []int, c chan int) {
    sum := 0
    for _, v := range s {
        sum += v
    }
    c &lt;- sum // Send the sum to the channel c
}

func main() {
    s := []int{7, 2, 8, -9, 4, 0}

    c := make(chan int) // Create a channel to communicate the result

    // Split the work into two goroutines
    go sum(s[:len(s)/2], c)
    go sum(s[len(s)/2:], c)

    // Receive the results from the channel
    // The main goroutine will block here until both sums are received
    x, y := &lt;-c, &lt;-c

    fmt.Println(x, y, x+y)
    // Output: -1 17 16 (or 17 -1 16, order is not guaranteed)
}
    </code></pre>
        <p>In this example, the `main` goroutine blocks at `x, y := &lt;-c, &lt;-c`, waiting for both `sum` goroutines to finish their work and send their results to the channel. This is a much more robust way to synchronize than using `time.Sleep`.</p>



        <!-- Common Concurrency Patterns -->
        <h2><i class="bi bi-diagram-2"></i> 3. Common Concurrency Patterns</h2>

        <h3>The `select` Statement</h3>
        <p>
            The <code>select</code> statement lets a goroutine wait on multiple channel operations. A `select` blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready. This is a powerful tool for handling multiple channels.
        </p>

        <pre><code class="language-go">
package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 &lt;- &quot;one&quot;
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 &lt;- &quot;two&quot;
    }()

    // We will wait for both messages, but the select will handle them as they arrive.
    for i := 0; i &lt; 2; i++ {
        select {
        case msg1 := &lt;-c1:
            fmt.Println(&quot;received&quot;, msg1)
        case msg2 := &lt;-c2:
            fmt.Println(&quot;received&quot;, msg2)
        }
    }
}
// Output:
// received one
// received two
    </code></pre>

        <h4>Timeouts with `select`</h4>
        <p>A common use for `select` is to implement timeouts. We can use `time.After` which returns a channel that sends a value after a specified duration.</p>
        <pre><code class="language-go">
// Inside a select block:
select {
case res := &lt;-c1:
    fmt.Println(res)
case &lt;-time.After(1 * time.Second):
    fmt.Println(&quot;timeout 1&quot;)
}
    </code></pre>

        <h3>Fan-Out, Fan-In Pattern</h3>
        <p>This is a powerful pattern for parallelizing work. A single "producer" goroutine generates jobs and sends them to multiple "worker" goroutines (fan-out). These workers process the jobs concurrently. The results are then collected by a single "consumer" goroutine (fan-in).</p>

        <div class="text-center my-4">
            <pre class="mermaid">
  <script type="text/plain">
    graph LR
                Producer["Producer"] --> JobsChannel["Jobs Channel"];
                JobsChannel -- "Fan-Out" --> Worker1["Worker 1"];
                JobsChannel -- "Fan-Out" --> Worker2["Worker 2"];
                JobsChannel -- "Fan-Out" --> Worker3["Worker 3"];

                Worker1 --> ResultsChannel["Results Channel"];
                Worker2 --> ResultsChannel["Results Channel"];
                Worker3 --> ResultsChannel["Results Channel"];

                ResultsChannel -- "Fan-In" --> Consumer["Consumer"];
  </script>
</pre>
            <small class="text-muted">Diagram: The Fan-Out, Fan-In Concurrency Pattern</small>
        </div>

        <pre><code class="language-go">
package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

// worker function that receives jobs and sends results
func worker(id int, jobs &lt;-chan int, results chan&lt;- int) {
    for j := range jobs {
        fmt.Printf(&quot;worker %d started job %d\n&quot;, id, j)
        // Simulate work
        time.Sleep(time.Second)
        fmt.Printf(&quot;worker %d finished job %d\n&quot;, id, j)
        results &lt;- j * 2
    }
}

func main() {
    const numJobs = 5
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)

    // Start 3 worker goroutines (Fan-Out)
    for w := 1; w &lt;= 3; w++ {
        go worker(w, jobs, results)
    }

    // Send 5 jobs to the jobs channel
    for j := 1; j &lt;= numJobs; j++ {
        jobs &lt;- j
    }
    close(jobs) // Close the jobs channel to signal no more jobs are coming

    // Collect the results (Fan-In)
    for a := 1; a &lt;= numJobs; a++ {
        &lt;-results
    }
    fmt.Println(&quot;All jobs are done.&quot;)
}
    </code></pre>



        <h2>Conclusion</h2>
        <p>Go's concurrency model, built on the simplicity of goroutines and the synchronization power of channels, is a paradigm shift from traditional threading models. It provides a robust and less error-prone way to build highly concurrent applications, which is essential for modern cloud-native services that need to handle massive scale and I/O-bound workloads efficiently. Mastering these concepts is key to unlocking the full potential of Go.</p>
    </section>
</div>