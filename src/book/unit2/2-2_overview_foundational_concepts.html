<div class="topic-content">
    <header class="topic-header" aria-label="Header">
        <h1 class="topic-title">Unit 2.2: Overview &amp; Foundational Concepts</h1>
        <p class="topic-intro">Now that your Go environment is ready, let's explore the foundational concepts of the language. Coming from a language like Python, you'll find Go to be refreshingly simple yet powerful. It's statically typed, compiled, and built with concurrency as a first-class citizen. This topic will bridge your existing programming knowledge to the Go way of thinking, focusing on the features most relevant to building high-performance backend services.</p>
    </header>

    <section>

        <h2><i class="bi bi-cloud"></i> Why Go for the Cloud? The Language Features Behind the Hype</h2>
        <p>In the previous topic, we mentioned Go's strengths. Now let's connect those strengths to its core language features:</p>

        <div class="content-row">
            <div class="content-col">
                <div class="content-card">
                    <h3><i class="bi bi-lightning-charge"></i> Performance through Simplicity</h3>
                    <p>Go is statically typed and compiles to machine code. This eliminates the overhead of an interpreter (like in Python) and allows for aggressive optimizations, resulting in faster execution. Its simple, small syntax also leads to a faster compiler.</p>
                </div>

                <div class="content-card">
                    <h3><i class="bi bi-diagram-3"></i> Concurrency via Goroutines</h3>
                    <p>Go's built-in goroutines and channels (which we'll cover in the next topic) provide a simple and powerful model for concurrency, making it trivial to build services that can handle tens of thousands of simultaneous connections.</p>
                </div>

                <div class="content-card">
                    <h3><i class="bi bi-box-seam"></i> Static Binaries from a Strong Type System</h3>
                    <p>The static type system ensures that all dependencies can be resolved at compile time. The compiler then links everything into a single executable file with no external dependencies, perfect for containerization.</p>
                </div>

                <div class="content-card">
                    <h3><i class="bi bi-code-slash"></i> Readability by Convention</h3>
                    <p>Go's tooling (like `gofmt`) enforces a single, idiomatic style. This, combined with features like implicit interfaces, leads to code that is easy to read and maintain, even in large teams.</p>
                </div>
            </div>
        </div>

        <h2><i class="bi bi-braces"></i> Core Language Features: A Tour for the Experienced Developer</h2>
        <p>
            As an experienced developer, you don't need a tutorial on basic programming concepts. Instead, this section focuses on Go-specific syntax and idioms that are most relevant for building cloud-native applications, especially those aspects that differ significantly from what you might be used to in Python or other languages.
        </p>

        <h3>Variables and Type Declaration</h3>
        <p>Go has a straightforward yet flexible approach to variable declaration. Unlike Python, you must declare types (though Go's type inference can often help):</p>

        <pre><code class="language-go">
// Explicit type declaration
var name string = &quot;John&quot;
var age int = 30

// Type inference (Go infers the type)
var city = &quot;New York&quot;        // inferred as string
var population = 8_000_000   // inferred as int

// Short variable declaration (only inside functions)
country := &quot;USA&quot;  // inferred as string
coordinates := [2]float64{40.7128, -74.0060} // array
        </code></pre>

        <h3>Functions and Multiple Return Values</h3>
        <p>Go functions can return multiple values, which is particularly useful for error handling:</p>

        <pre><code class="language-go">
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New(&quot;division by zero&quot;)
    }
    return a / b, nil
}

// Usage
result, err := divide(10, 2)
if err != nil {
    log.Fatal(err)
}
fmt.Printf(&quot;Result: %.2f\n&quot;, result)
        </code></pre>

        <h3>Structs and Methods</h3>
        <p>Go uses structs instead of classes. Methods are functions with a special receiver argument:</p>

        <pre><code class="language-go">
type Person struct {
    Name    string
    Age     int
    Email   string
}

// Method with a receiver
func (p Person) GetInfo() string {
    return fmt.Sprintf(&quot;%s (%d years old)&quot;, p.Name, p.Age)
}

// Method with pointer receiver (can modify the struct)
func (p *Person) UpdateEmail(email string) {
    p.Email = email
}

// Usage
person := Person{Name: &quot;Alice&quot;, Age: 30, Email: &quot;alice@example.com&quot;}
fmt.Println(person.GetInfo())
person.UpdateEmail(&quot;alice.new@example.com&quot;)
        </code></pre>

        <h3>Interfaces</h3>
        <p>Go interfaces are satisfied implicitly. Any type that implements the methods of an interface automatically satisfies that interface:</p>

        <pre><code class="language-go">
type Writer interface {
    Write([]byte) (int, error)
}

type Logger struct {
    prefix string
}

// Logger satisfies the Writer interface by implementing Write
func (l Logger) Write(data []byte) (int, error) {
    message := fmt.Sprintf(&quot;[%s] %s&quot;, l.prefix, string(data))
    return fmt.Print(message)
}

// Usage
var w Writer = Logger{prefix: &quot;INFO&quot;}
w.Write([]byte(&quot;Application started&quot;))
        </code></pre>

        <h3>Error Handling</h3>
        <p>Go's approach to error handling is explicit and different from exception-based languages:</p>

        <pre><code class="language-go">
func readConfig(filename string) (*Config, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, fmt.Errorf(&quot;failed to open config file: %w&quot;, err)
    }
    defer file.Close()

    var config Config
    err = json.NewDecoder(file).Decode(&amp;config)
    if err != nil {
        return nil, fmt.Errorf(&quot;failed to parse config: %w&quot;, err)
    }

    return &amp;config, nil
}

// Usage with proper error handling
config, err := readConfig(&quot;app.json&quot;)
if err != nil {
    log.Fatal(err)
}
// Use config...
        </code></pre>

        <h3>Slices and Maps</h3>
        <p>Go's built-in data structures are powerful yet simple:</p>

        <pre><code class="language-go">
// Slices (dynamic arrays)
var numbers []int                    // nil slice
numbers = append(numbers, 1, 2, 3)  // [1, 2, 3]
subset := numbers[1:]                // [2, 3]

// Maps
users := make(map[string]int)
users[&quot;alice&quot;] = 25
users[&quot;bob&quot;] = 30

// Or initialize with values
permissions := map[string]bool{
    &quot;read&quot;:  true,
    &quot;write&quot;: false,
    &quot;admin&quot;: true,
}

// Check if key exists
if age, exists := users[&quot;alice&quot;]; exists {
    fmt.Printf(&quot;Alice is %d years old\n&quot;, age)
}
        </code></pre>
    </section>
</div>