<div class="topic-content">
    <header class="topic-header" aria-label="Header">
        <h1 class="topic-title">Unit 2.8: Testing Strategies</h1>
    </header>

    <section>
        <h2><i class="bi bi-triangle"></i> The Testing Pyramid in Go</h2>
        <p>
            The Testing Pyramid is a valuable model for structuring your testing efforts. The core idea is to have a large base of fast unit tests, a smaller layer of integration tests, and a tiny number of slow end-to-end tests.
        </p>
        <div class="text-center my-4">
            <pre class="mermaid">
  <script type="text/plain">
    graph LR
                A["End-to-End Tests (Few, Slow, Brittle)"]
                B["Integration Tests (More, Slower)"]
                C["Unit Tests (Many, Fast, Isolated)"]

                C --> B;
                B --> A;

                style A fill:#f9d6d5,stroke:#333,stroke-width:2px
                style B fill:#f5b7b1,stroke:#333,stroke-width:2px
                style C fill:#ec7063,stroke:#333,stroke-width:2px
  </script>
</pre>
            <small class="text-muted">Diagram: The Testing Pyramid</small>
        </div>
        <ul>
            <li><strong>Unit Tests:</strong> Verify a single piece of functionality (usually a single function or method) in isolation.</li>
            <li><strong>Integration Tests:</strong> Verify that multiple components work together correctly (e.g., your service and a real database).</li>
            <li><strong>End-to-End Tests:</strong> Verify the entire system from the user's perspective.</li>
        </ul>
        <p>This topic focuses on the foundation: unit and integration tests.</p>



        <!-- Unit Testing -->
        <h2><i class="bi bi-file-earmark-code"></i> 1. Unit and Integration Testing with the `testing` Package</h2>
        <p>
            Go's built-in <code>testing</code> package provides all the tools you need. Tests are placed in files ending with <code>_test.go</code> and are co-located with the code they are testing. The <code>go test</code> command automatically discovers and runs these tests.
        </p>

        <h4>Basic Unit Test</h4>
        <p>A test function is defined with the signature <code>func TestXxx(t *testing.T)</code>, where `Xxx` is a name starting with a capital letter.</p>
        <pre><code class="language-go">
// file: math/add.go
package math

func Add(a, b int) int {
    return a + b
}

// file: math/add_test.go
package math

import &quot;testing&quot;

func TestAdd(t *testing.T) {
    got := Add(2, 3)
    want := 5

    if got != want {
        t.Errorf(&quot;Add(2, 3) = %d; want %d&quot;, got, want)
    }
}
    </code></pre>

        <h4>Table-Driven Tests</h4>
        <p>A common and idiomatic pattern in Go is the <strong>table-driven test</strong>, where you define a slice of test cases (the "table") and iterate over them. This makes it easy to test many different inputs and edge cases with minimal boilerplate.</p>
        <pre><code class="language-go">
// file: math/add_test.go
package math

import &quot;testing&quot;

func TestAddTableDriven(t *testing.T) {
    var tests = []struct {
        name string
        a, b int
        want int
    }{
        {&quot;positive numbers&quot;, 2, 3, 5},
        {&quot;negative numbers&quot;, -1, -1, -2},
        {&quot;zero&quot;, 0, 0, 0},
        {&quot;positive and negative&quot;, -5, 5, 0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ans := Add(tt.a, tt.b)
            if ans != tt.want {
                t.Errorf(&quot;got %d, want %d&quot;, ans, tt.want)
            }
        })
    }
}
    </code></pre>



        <!-- Mocking -->
        <h2><i class="bi bi-person-bounding-box"></i> 2. Mocking Interfaces</h2>
        <p>
            To write effective unit tests, you must isolate the component under test from its dependencies (like databases or external APIs). In Go, this is achieved naturally and elegantly using <strong>interfaces</strong>. Instead of mocking concrete types, you define your dependencies as interfaces and provide a "mock" implementation of that interface during tests.
        </p>

        <div class="text-center my-4">
            <pre class="mermaid">
  <script type="text/plain">
    graph TD
                A["Business Logic Function"] -- "Depends on" --> B(DataStore Interface);
                subgraph Production
                    C["PostgresDB Struct"] -- "Implements" --> B;
                end
                subgraph Testing
                    D["MockDataStore Struct"] -- "Implements" --> B;
                end
                A -- "Uses in Test" --> D;
                A -- "Uses in Prod" --> C;
  </script>
</pre>
            <small class="text-muted">Diagram: Dependency Injection and Mocking with Interfaces</small>
        </div>

        <h4>Example: Mocking a Database Dependency</h4>
        <p>Imagine a service that retrieves a user. First, we define the interface for our data store.</p>
        <pre><code class="language-go">
// file: store/user_store.go
package store

type User struct {
    ID   int
    Name string
}

// UserStorer is an interface that defines how to interact with user data.
// Any type that implements GetUserByID satisfies this interface.	ype UserStorer interface {
    GetUserByID(id int) (*User, error)
}

// Service uses the interface, not a concrete database type.
type Service struct {
    store UserStorer
}

func (s *Service) GetUserName(id int) (string, error) {
    user, err := s.store.GetUserByID(id)
    if err != nil {
        return &quot;&quot;, err
    }
    return user.Name, nil
}
    </code></pre>

        <p>Now, we can create a mock implementation for our tests.</p>
        <pre><code class="language-go">
// file: store/user_store_test.go
package store

import (
    &quot;errors&quot;
    &quot;testing&quot;
)

// MockUserStore is a mock implementation of the UserStorer interface.
type MockUserStore struct {
    users map[int]User
}

// Implement the GetUserByID method for the mock.
func (m *MockUserStore) GetUserByID(id int) (*User, error) {
    user, ok := m.users[id]
    if !ok {
        return nil, errors.New(&quot;user not found&quot;)
    }
    return &amp;user, nil
}

func TestGetUserName(t *testing.T) {
    // Setup the mock with some data
    mockStore := &amp;MockUserStore{
        users: map[int]User{
            1: {ID: 1, Name: &quot;Alice&quot;},
        },
    }

    // Inject the mock into our service
    service := &amp;Service{store: mockStore}

    // Test the success case
    name, err := service.GetUserName(1)
    if err != nil {
        t.Fatalf(&quot;expected no error, got %v&quot;, err)
    }
    if name != &quot;Alice&quot; {
        t.Errorf(&quot;expected name Alice, got %s&quot;, name)
    }

    // Test the error case
    _, err = service.GetUserName(2)
    if err == nil {
        t.Fatal(&quot;expected an error, got nil&quot;)
    }
}
    </code></pre>



        <!-- Testcontainers -->
        <h2><i class="bi bi-box-seam"></i> 3. Emulating Services with Testcontainers</h2>
        <p>
            For integration tests, mocking is not enough. You need to verify that your application works correctly with real dependencies. <strong>Testcontainers for Go</strong> is a library that makes it easy to spin up and manage ephemeral Docker containers for your tests.
        </p>

        <h4>Installation</h4>
        <pre><code class="language-bash">go get github.com/testcontainers/testcontainers-go</code></pre>

        <h4>Example: Integration Test with a Real PostgreSQL Database</h4>
        <p>Let's write an integration test for a function that creates a user in a real PostgreSQL database.</p>
        <pre><code class="language-go">
// file: db/user_repo_integration_test.go
package db

import (
    &quot;context&quot;
    &quot;testing&quot;

    &quot;github.com/testcontainers/testcontainers-go&quot;
    &quot;github.com/testcontainers/testcontainers-go/modules/postgres&quot;
    &quot;gorm.io/driver/postgres&quot;
    &quot;gorm.io/gorm&quot;
)

// This test will spin up a real PostgreSQL container.
func TestCreateUserIntegration(t *testing.T) {
    ctx := context.Background()

    // 1. Create a new PostgreSQL container
    pgContainer, err := postgres.RunContainer(ctx,
        testcontainers.WithImage(&quot;docker.io/postgres:15-alpine&quot;),
        postgres.WithDatabase(&quot;test-db&quot;),
        postgres.WithUsername(&quot;user&quot;),
        postgres.WithPassword(&quot;password&quot;),
        testcontainers.WithWaitStrategy(wait.ForLog(&quot;database system is ready to accept connections&quot;).WithOccurrence(2)),
    )
    if err != nil {
        t.Fatalf(&quot;failed to start container: %s&quot;, err)
    }
    // Clean up the container after the test is complete
    defer func() {
        if err := pgContainer.Terminate(ctx); err != nil {
            t.Fatalf(&quot;failed to terminate container: %s&quot;, err)
        }
    }()

    // 2. Get the connection string from the container
    connStr, err := pgContainer.ConnectionString(ctx, &quot;sslmode=disable&quot;)
    if err != nil {
        t.Fatalf(&quot;failed to get connection string: %s&quot;, err)
    }

    // 3. Connect to the test database using GORM
    db, err := gorm.Open(postgres.Open(connStr), &amp;gorm.Config{})
    if err != nil {
        t.Fatalf(&quot;failed to connect to db: %s&quot;, err)
    }

    // 4. Run the test logic against the real database
    repo := NewUserRepository(db) // Assume NewUserRepository creates your repo struct
    err = repo.CreateUser(ctx, &amp;User{Name: &quot;Test User&quot;})
    if err != nil {
        t.Fatalf(&quot;CreateUser failed: %s&quot;, err)
    }

    // Verify the user was created
    user, err := repo.GetUserByName(ctx, &quot;Test User&quot;)
    if err != nil {
        t.Fatalf(&quot;GetUserByName failed: %s&quot;, err)
    }
    if user.Name != &quot;Test User&quot; {
        t.Errorf(&quot;expected user name &#x27;Test User&#x27;, got &#x27;%s&#x27;&quot;, user.Name)
    }
}
    </code></pre>
    </section>
</div>