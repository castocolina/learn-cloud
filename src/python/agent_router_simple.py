#!/usr/bin/env python3
"""
AI Agent Router - Simple CLI Version
====================================

This version uses simple CLI input/output instead of curses TUI to avoid
terminal compatibility issues while providing the same functionality.
"""

import yaml
import json
import subprocess
import sys
import os
import textwrap
import random
import string
import readline  # For better input editing
import threading
import time
from datetime import datetime
from typing import Dict, List, Any, Tuple

# Global default timeout for agent responses (in seconds)
DEFAULT_AGENT_TIMEOUT = 60

# ANSI color codes for better visual feedback
class Colors:
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    
    # Foreground colors
    BLACK = '\033[30m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    
    # Background colors
    BG_BLACK = '\033[40m'
    BG_RED = '\033[41m'
    BG_GREEN = '\033[42m'
    BG_YELLOW = '\033[43m'
    BG_BLUE = '\033[44m'
    BG_MAGENTA = '\033[45m'
    BG_CYAN = '\033[46m'
    BG_WHITE = '\033[47m'
    BG_GRAY = '\033[100m'

class AgentRouterCLI:
    def __init__(self, agents_file: str = None):
        self.show_strategist_prompt = False  # Toggle for showing strategist prompt
        # Auto-detect correct paths based on current working directory
        if agents_file is None:
            if os.path.exists("../conf/agents.yaml"):  # Running from src/python/
                self.agents_file = "../conf/agents.yaml"
                self.prompts_file = "../conf/agent_prompts.yaml"
            elif os.path.exists("src/conf/agents.yaml"):  # Running from project root
                self.agents_file = "src/conf/agents.yaml"
                self.prompts_file = "src/conf/agent_prompts.yaml"
            else:
                raise FileNotFoundError("Cannot find agents.yaml - please run from project root or src/python directory")
        else:
            self.agents_file = agents_file
            # Set prompts file relative to agents file location
            agents_dir = os.path.dirname(agents_file)
            self.prompts_file = os.path.join(agents_dir, "agent_prompts.yaml")
        
        self.agents = self.load_agents()
        
    def generate_prompt_id(self) -> str:
        """Generate a unique 3-5 character alphanumeric ID"""
        length = random.randint(3, 5)
        return ''.join(random.choices(string.ascii_uppercase + string.digits, k=length))
    
    def load_existing_prompts(self) -> List[Dict[str, Any]]:
        """Load existing prompts from YAML file"""
        try:
            if os.path.exists(self.prompts_file):
                with open(self.prompts_file, 'r', encoding='utf-8') as file:
                    data = yaml.safe_load(file)
                    # Handle case where file is empty or contains only None/null
                    if data is None:
                        return []
                    if isinstance(data, dict):
                        prompts = data.get('prompts', [])
                        # Ensure prompts is always a list
                        return prompts if isinstance(prompts, list) else []
                    return []
            return []
        except (FileNotFoundError, yaml.YAMLError) as e:
            print(f"‚ö†Ô∏è  Warning: Could not load existing prompts: {e}")
            return []
    
    def save_prompt_entry(self, user_problem: str, decision: Dict[str, Any], 
                         satisfied: bool, additional_context: str = "", execution_scope: str = 'single') -> str:
        """Save a new prompt entry to the prompts YAML file"""
        # Generate unique ID
        prompt_id = self.generate_prompt_id()
        existing_prompts = self.load_existing_prompts()
        
        # Ensure ID is unique
        existing_ids = [p.get('id', '') for p in existing_prompts]
        while prompt_id in existing_ids:
            prompt_id = self.generate_prompt_id()
        
        # Check decision content
        if not decision:
            print(f"‚ùå Error: decision is None or empty")
            return ""
        
        # Get agent details
        agent_id = decision.get('agent_id', 'Unknown')
        selected_agent = next((agent for agent in self.agents if agent['id'] == agent_id), None)
        
        # Use the prompt as generated by Solution Strategist (should already include role)
        # Prefer the raw format with preserved line breaks for better markdown formatting
        final_prompt = decision.get('draft_prompt_raw', decision.get('draft_prompt', 'No prompt provided'))
        
        now = datetime.now()
        prompt_entry = {
            'id': prompt_id,
            'prompt': final_prompt,
            'agent_id': agent_id,
            'agent_role': selected_agent['description'] if selected_agent else 'Unknown',
            'agent_name': selected_agent['agent_name'] if selected_agent else 'unknown',
            'model': selected_agent['model'] if selected_agent else 'unknown',
            'framework': selected_agent['framework'] if selected_agent else 'Unknown',
            'status': 'enabled' if satisfied else 'needs_refinement',
            'created': now.isoformat(),
            'last_execution': None,
            'iterations': 1,
            'last_result': None,
            'user_problem': user_problem,
            'additional_context': additional_context if additional_context else None,
            'execution_scope': execution_scope,
            'metadata': {
                'questions_asked': decision.get('questions', []),
                'complete': decision.get('complete', False),
                'router_command': f"gemini -m gemini-2.5-pro -a -p \"[PROMPT_CONTENT]\"",
                'execution_command': f"{selected_agent['agent_name'] if selected_agent else 'unknown'} {'--model' if selected_agent and selected_agent['agent_name'] == 'claude' else '-m'} {selected_agent['model'] if selected_agent else 'unknown'} -a -p \"{{prompt}}\"",
                'scope_type': execution_scope
            }
        }
        
        # Add to existing prompts
        existing_prompts.append(prompt_entry)
        
        # Save to file
        try:
            # Create directory based on prompts file path
            prompts_dir = os.path.dirname(self.prompts_file)
            os.makedirs(prompts_dir, exist_ok=True)
            with open(self.prompts_file, 'w', encoding='utf-8') as file:
                yaml.dump({'prompts': existing_prompts}, file, default_flow_style=False, 
                         allow_unicode=True, sort_keys=False)
            return prompt_id
        except IOError as e:
            print(f"‚ùå Error saving prompt: {e}")
            return ""
    
    def load_agents(self):
        """Load agents configuration from YAML file"""
        try:
            with open(self.agents_file, 'r', encoding='utf-8') as file:
                data = yaml.safe_load(file)
                return data.get('agents', [])
        except FileNotFoundError:
            print(f"‚ùå Error: {self.agents_file} not found!")
            sys.exit(1)
        except yaml.YAMLError as e:
            print(f"‚ùå Error parsing YAML: {e}")
            sys.exit(1)
    
    def print_header(self):
        """Print the application header"""
        print("\n" + "="*70)
        print("ü§ñ AI Agent Router - Prompt Generator CLI")
        print("="*70)
        print("Interactive prompt generation for specialized AI agents")
        print("="*70)
    
    def configure_readline_for_input(self):
        """Configure readline for better text input behavior with comprehensive wrapping fix"""
        try:
            # Clear any existing problematic state
            readline.clear_history()
            readline.set_completer(None)
            readline.set_completer_delims(' \t\n`@#$%^&*()=+[{]}\\|;:\'\"<>?')
            
            # Critical settings to prevent text wrapping issues
            readline.parse_and_bind("set horizontal-scroll-mode off")  # CRITICAL: Prevents cursor return to start
            readline.parse_and_bind("set enable-keypad on")           # Better arrow key handling
            readline.parse_and_bind("set editing-mode emacs")         # Consistent editing mode
            readline.parse_and_bind("set bell-style none")            # Disable annoying bell
            readline.parse_and_bind("set show-all-if-ambiguous on")   # Better completion
            readline.parse_and_bind("set completion-ignore-case on")  # Case insensitive
            readline.parse_and_bind("set skip-completed-text on")     # Better completion behavior
            
            # Display and wrapping related settings
            readline.parse_and_bind("set mark-directories on")
            readline.parse_and_bind("set mark-symlinked-directories on") 
            readline.parse_and_bind("set match-hidden-files off")
            
            # Clear hooks that might interfere with display
            readline.set_completion_display_matches_hook(None)
            readline.set_pre_input_hook(None)
            readline.set_startup_hook(None)
            
            # Force terminal-aware settings (screenwidth is not supported in all readline versions)
            import os, shutil
            terminal_width = shutil.get_terminal_size().columns
            if terminal_width > 40:  # Only if we have reasonable width
                # Note: screenwidth is not universally supported, so we skip it
                pass
            
        except Exception as e:
            # Fallback to minimal configuration if anything fails
            try:
                readline.parse_and_bind("set horizontal-scroll-mode off")
                readline.parse_and_bind("set editing-mode emacs")
                print(f"Warning: Limited readline configuration applied: {e}")
            except Exception:
                print("Warning: Readline configuration failed entirely - text editing may be limited")
    
    def detect_multiline_paste(self, input_text: str) -> bool:
        """Detect if input has more than 5 consecutive empty lines (blank lines)"""
        lines = input_text.split('\n')
        consecutive_empty = 0
        max_consecutive_empty = 0
        
        for line in lines:
            if not line.strip():  # Empty or whitespace-only line
                consecutive_empty += 1
                max_consecutive_empty = max(max_consecutive_empty, consecutive_empty)
            else:
                consecutive_empty = 0
        
        return max_consecutive_empty > 5

    def get_multiline_input(self, prompt: str) -> str:
        """Get multiline input from user with enhanced editing capabilities and paste detection"""
        # Configure readline for better behavior
        self.configure_readline_for_input()
        
        print(f"\n{prompt}")
        print("=" * len(prompt))
        print("üí° Enhanced editing tips:")
        print("  - Use arrow keys to navigate and edit text")
        print("  - Use Home/End to jump to beginning/end of line")  
        print("  - Use Ctrl+A/E for line beginning/end (alternative)")
        print("  - Type multiple lines - press Enter for new line")
        print("  - Paste detection: >5 consecutive blank lines will prompt for confirmation")
        current_status = "ON" if self.show_strategist_prompt else "OFF"
        print(f"  - Type {Colors.YELLOW}/tp{Colors.RESET} to toggle Solution Strategist prompt (currently {Colors.BOLD}{current_status}{Colors.RESET})")
        print(f"  - Type {Colors.YELLOW}/help{Colors.RESET} for special commands")
        print("  - Press Ctrl+D when done or Ctrl+C to cancel")
        print("-" * 50)
        
        lines = []
        line_number = 1
        
        try:
            while True:
                try:
                    # Set readline prompt with line number
                    readline.set_startup_hook(None)
                    line_prompt = f"{Colors.DIM}[{line_number:2d}] {Colors.RESET}"
                    line = input(line_prompt)
                    
                    # Handle special commands
                    if line.strip().lower() in ['/toggle-prompt', '/tp']:
                        self.show_strategist_prompt = not self.show_strategist_prompt
                        status = "ON" if self.show_strategist_prompt else "OFF"
                        print(f"{Colors.GREEN}‚úÖ Solution Strategist prompt visibility: {status}{Colors.RESET}")
                        continue
                    elif line.strip().lower() == '/help':
                        print(f"{Colors.CYAN}üìã Special commands:{Colors.RESET}")
                        print("  /toggle-prompt, /tp - Toggle Solution Strategist prompt visibility")
                        print("  /help - Show this help")
                        continue
                    
                    # Detect multiline paste with too many blank lines
                    if self.detect_multiline_paste(line):
                        lines_in_paste = line.split('\n')
                        empty_lines = sum(1 for l in lines_in_paste if not l.strip())
                        print(f"\n{Colors.YELLOW}üìã Paste detected with many blank lines ({empty_lines} empty lines)!{Colors.RESET}")
                        print(f"Content preview: {repr(line[:100])}...")
                        confirm = input(f"{Colors.CYAN}Accept this paste? (y/N): {Colors.RESET}").strip().lower()
                        if confirm not in ['y', 'yes']:
                            print(f"{Colors.RED}‚ùå Paste rejected. Please enter text manually or paste with fewer blank lines.{Colors.RESET}")
                            continue
                        else:
                            print(f"{Colors.GREEN}‚úÖ Paste accepted{Colors.RESET}")
                    
                    if line.strip():  # Non-empty line
                        # Split pasted content into lines if it contains newlines
                        if '\n' in line:
                            pasted_lines = line.split('\n')
                            lines.extend(pasted_lines)
                            line_number += len(pasted_lines)
                        else:
                            lines.append(line)
                            line_number += 1
                    else:  # Empty line - just add it and continue (removed problematic confirmation)
                        lines.append("")
                        line_number += 1
                        
                except EOFError:
                    # Ctrl+D pressed
                    break
        except KeyboardInterrupt:
            print(f"\n{Colors.RED}‚ùå Operation cancelled by user{Colors.RESET}")
            return ""
        
        result = '\n'.join(lines).strip()
        if result:
            print(f"{Colors.GREEN}‚úÖ Input captured ({len(lines)} lines){Colors.RESET}")
        return result
    
    def display_results(self, decision: Dict[str, Any], user_problem: str) -> bool:
        """Display results and get user feedback"""
        print("\n" + "="*70)
        print("üéØ PROMPT GENERATOR RECOMMENDATION")
        print("="*70)
        
        # Get selected agent info
        agent_id = decision.get('agent_id', 'Unknown')
        selected_agent = next((agent for agent in self.agents if agent['id'] == agent_id), None)
        
        # Agent info
        if selected_agent:
            print(f"ü§ñ Agent: {selected_agent['name']} ({agent_id})")
            print(f"üõ†Ô∏è  Framework: {selected_agent['framework']}")
            print(f"üìã Role: {selected_agent['description']}")
            print()
        
        # Draft prompt (show more for agent 01O, truncated for others) - use raw version with preserved line breaks
        draft_prompt_raw = decision.get('draft_prompt_raw', decision.get('draft_prompt', 'No prompt provided'))
        print("üìù Generated Prompt:")
        print("-" * 50)
        
        # Show complete prompt without truncation
        prompt_lines = draft_prompt_raw.split('\n')
        for line in prompt_lines:
            # Handle empty lines (preserve spacing)
            if not line.strip():
                print()
            else:
                # Wrap long lines but preserve structure
                wrapped = textwrap.fill(line, width=66, initial_indent="   ", subsequent_indent="   ")
                print(wrapped)
        print("-" * 50)
        
        # Status
        is_complete = decision.get('complete', False)
        status = "‚úÖ Complete" if is_complete else "‚è≥ Needs refinement"
        print(f"üìä Status: {status}")
        
        # Questions at the end (most important info last)
        questions = decision.get('questions', [])
        if questions:
            print(f"\n‚ùì {Colors.BOLD}Outstanding Questions:{Colors.RESET}")
            for i, question in enumerate(questions, 1):
                wrapped = textwrap.fill(f"{i}. {question}", width=66, initial_indent="   ", subsequent_indent="      ")
                print(wrapped)
        
        # Get feedback with corrected logic
        print(f"\nüí¨ {Colors.BOLD}What would you like to do?{Colors.RESET}")
        print(f"   {Colors.GREEN}y/Y{Colors.RESET} = Accept this prompt (save and use)")
        print(f"   {Colors.YELLOW}n/N{Colors.RESET} = Need refinement (re-consult Solution Strategist)")
        print(f"   {Colors.RED}m/M{Colors.RESET} = Manual context only (add context without re-consulting)")
        
        while True:
            try:
                response = input(f"\n{Colors.CYAN}Your choice (y/n/m): {Colors.RESET}").strip().lower()
                if response in ['y', 'yes']:
                    return True  # Accept prompt
                elif response in ['n', 'no']:
                    return 'modify'  # Re-consult Solution Strategist
                elif response in ['m', 'modify', 'manual']:
                    return False  # Manual context only, don't re-consult
                else:
                    print(f"{Colors.RED}‚ùå Please enter 'y' to accept, 'n' to refine, or 'm' for manual context{Colors.RESET}")
            except (EOFError, KeyboardInterrupt):
                print(f"\n{Colors.YELLOW}üëã Exiting...{Colors.RESET}")
                return None  # Return None to indicate cancellation
    
    def format_agents_for_prompt(self) -> str:
        """Format agents list for the router prompt with complete information"""
        agents_list = []
        for agent in self.agents:
            if agent['id'] != 'SS01':  # Exclude the router itself
                agents_list.append(
                    f"- ID: {agent['id']}\n"
                    f"  Name: {agent['name']}\n"
                    f"  Description/Role: {agent['description']}\n"
                    f"  Framework: {agent['framework']}\n"
                    f"  Agent Command: {agent['agent_name']}\n"
                    f"  Model: {agent['model']}"
                )
        return "\n\n".join(agents_list)
    
    def get_scope_instructions(self, execution_scope: str) -> str:
        """Generate scope-specific instructions for the router agent"""
        if execution_scope == 'per-unit':
            return """
IMPORTANT: This prompt will be executed individually for each unit of the book. Therefore:

1. The generated prompt MUST use "Unit X" as a placeholder that will be replaced with actual unit numbers (Unit 1, Unit 2, etc.)
2. Specify paths using "src/book/unitX/" as the base directory for unit-specific files
3. The agent should ONLY modify files in Unit X or general resources (index.html, main CSS/JS) if strictly necessary
4. The agent CAN consult other units for consistency and structure understanding, but should NOT modify them
5. Emphasize that this is a template that will be applied to multiple units

Include this emphasis in your generated prompt: "CRITICAL: You are working on Unit X. Use 'Unit X' and 'src/book/unitX/' in all references. Only modify Unit X files or global resources if absolutely necessary."
"""
        else:
            return """
This is a single execution that affects the entire project. The agent can modify files as needed including:
- index.html (main entry point)
- src/book/style.css and src/book/app.js (global resources)
- Any unit directories (src/book/unit1/, src/book/unit2/, etc.) as needed
- Other project files if required

IMPORTANT GUIDELINES:
1. If editing specific unit files, clearly specify WHICH files are being modified and WHY
2. Consider the impact on ALL units when making changes to unit-specific files
3. Prefer modifying global resources (CSS, JS, index.html) over individual unit files when possible
4. If unit-specific changes are needed, provide clear rationale and ensure consistency across units

Focus on a comprehensive solution that addresses the problem globally while being precise about any unit-specific modifications.
"""
    
    def call_router_agent(self, user_problem: str, execution_scope: str = 'single') -> str:
        """Call the Solution Strategist (router) agent"""
        router_agent = next((agent for agent in self.agents if agent['id'] == 'SS01'), None)
        
        if not router_agent:
            print("‚ùå Router agent (SS01) not found!")
            return ""
        
        agents_info = self.format_agents_for_prompt()
        
        # Add scope-specific instructions
        scope_instructions = self.get_scope_instructions(execution_scope)
        
        # Use multiline YAML format without escaping
        prompt = f"""CRITICAL: You are ONLY a prompt generator. You must NOT generate any solutions, code, or content. Your ONLY job is to analyze the problem and generate an optimized prompt for another agent.

The user has a problem with the current project:
"{user_problem}"

EXECUTION SCOPE: {execution_scope.upper()}
{scope_instructions}

Evaluate using the framework "{router_agent['framework']}" (Reason + Act approach).

I have several agents and one of them might be able to generate the solution:

{agents_info}

IMPORTANT: Your role is EXCLUSIVELY to:
1. Recommend which agent should handle this task
2. Ask clarifying questions if needed
3. Generate an optimized prompt for that agent
4. You must NOT provide any solutions yourself

You must indicate in a structured YAML format using multiline syntax:
- agent_id: ID of the recommended agent
- questions: list of questions you need answered to complete the framework (if any)
- draft_prompt: >-
    A complete, optimized prompt for the selected agent.
    CRITICAL: The prompt MUST start with the agent's role/persona definition.
    Use the agent's description as their persona, then include their framework and the task.
    Use YAML multiline format (>-) to avoid escaping quotes and special characters.
    
    MANDATORY FORMAT:
    draft_prompt: >-
      You are [AGENT_DESCRIPTION_HERE].
      
      Framework: [AGENT_FRAMEWORK_HERE]
      
      Your task is to help solve the following problem:
      [USER_PROBLEM_DESCRIPTION]
      
      [Additional instructions based on the framework]
      
    Example:
    draft_prompt: >-
      You are an expert software engineer specializing in modern web development with React, Vue, and Node.js.
      
      Framework: Component-Based Development
      
      Your task is to help solve the following problem:
      Create a responsive navigation component with mobile hamburger menu
      
      Please provide a complete solution following component-based architecture principles.
- complete: true/false indicating if the prompt is complete or if questions need to be answered

Wrap your YAML response between ```yaml and ``` markers. Do not include any other text outside these markers.
"""
        
        print("üîÑ Consulting Solution Strategist...")
        print()
        
        # Show the full prompt being sent (toggleable with Ctrl+P)
        if self.show_strategist_prompt:
            print("üì§ Prompt sent to Solution Strategist:")
            print("=" * 70)
            print(prompt)
            print("=" * 70)
            print()
        
        # Build command with context (different logic for claude vs gemini)
        agent_name = router_agent['agent_name']
        primary_model = router_agent['model']
        fallback_model = router_agent.get('fallback_model')
        
        if agent_name == 'claude' and fallback_model:
            # For Claude: pass both primary and fallback models in single command
            cmd = [
                "claude", 
                "--model", primary_model,
                "--fallback-model", fallback_model,
                "-a", 
                "-p", prompt
            ]
            cmd_display = f"claude --model {primary_model} --fallback-model {fallback_model} -a -p \"[PROMPT_CONTENT]\""
        else:
            # For other agents (gemini): use traditional single model approach
            cmd = [
                agent_name, 
                "-m", primary_model,
                "-a",
                "-p", prompt
            ]
            cmd_display = f"{agent_name} -m {primary_model} -a -p \"[PROMPT_CONTENT]\""
        
        # Show command being executed with highlighted background
        highlighted_cmd = f"{Colors.BG_GRAY}{Colors.BLUE}{Colors.BOLD} {cmd_display} {Colors.RESET}"
        print(f"üñ•Ô∏è  Command: {highlighted_cmd}")
        
        # Start counter and execute command
        # Get agent timeout (use global default if not specified)
        agent_timeout = router_agent.get('timeout', DEFAULT_AGENT_TIMEOUT)  # Note: keeping typo as it exists in YAML
        if agent_timeout is None:
            agent_timeout = DEFAULT_AGENT_TIMEOUT
            
        counter_stop = threading.Event()
        counter_data = {'final_time': None}  # Shared data for final time
        counter_thread = threading.Thread(target=self.show_waiting_counter, args=(counter_stop, agent_timeout, counter_data))
        counter_thread.start()
            
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=agent_timeout)
            
            # Stop counter and get final time
            counter_stop.set()
            counter_thread.join()
            
            # Show final response time
            if counter_data['final_time']:
                elapsed_minutes = counter_data['final_time'] // 60
                elapsed_seconds = counter_data['final_time'] % 60
                if elapsed_minutes > 0:
                    time_str = f"{elapsed_minutes}m {elapsed_seconds:02d}s"
                else:
                    time_str = f"{elapsed_seconds:02d}s"
                print(f"\r‚úÖ Agent responded in {Colors.GREEN}{Colors.BOLD}{time_str}{Colors.RESET}")
            
            if result.returncode != 0:
                print(f"‚ùå Error calling gemini: {result.stderr}")
                return ""
            
            # Filter out gemini CLI messages
            output_lines = result.stdout.strip().split('\n')
            filtered_lines = []
            yaml_started = False
            
            for line in output_lines:
                if line.strip().startswith('```yaml'):
                    yaml_started = True
                    filtered_lines.append(line)
                elif line.strip().startswith('```') and yaml_started:
                    filtered_lines.append(line)
                    break
                elif yaml_started:
                    filtered_lines.append(line)
            
            return '\n'.join(filtered_lines)
            
        except subprocess.TimeoutExpired:
            counter_stop.set()
            counter_thread.join()
            print(f"\n‚ùå Timeout after {agent_timeout}s waiting for {router_agent.get('model', 'unknown model')} response")
            
            # Try fallback model if available (only for non-Claude agents, as Claude handles fallback internally)
            fallback_model = router_agent.get('fallback_model')
            if fallback_model and agent_name != 'claude':
                print(f"üîÑ Trying fallback model: {fallback_model}")
                
                # Reconstruct command with fallback model
                fallback_cmd = [
                    router_agent['agent_name'], 
                    '-m', fallback_model,
                    '-a', 
                    '-p', prompt
                ]
                
                # Show fallback command
                fallback_cmd_display = f"{router_agent['agent_name']} -m {fallback_model} -a -p \"[PROMPT_CONTENT]\""
                highlighted_fallback_cmd = f"{Colors.BG_GRAY}{Colors.YELLOW}{Colors.BOLD} {fallback_cmd_display} {Colors.RESET}"
                print(f"üîÑ Fallback Command: {highlighted_fallback_cmd}")
                
                # Start new counter for fallback
                fallback_counter_stop = threading.Event()
                fallback_counter_data = {'final_time': None}
                fallback_counter_thread = threading.Thread(target=self.show_waiting_counter, args=(fallback_counter_stop, agent_timeout, fallback_counter_data))
                fallback_counter_thread.start()
                
                try:
                    fallback_result = subprocess.run(fallback_cmd, capture_output=True, text=True, timeout=agent_timeout)
                    
                    # Stop fallback counter and show time
                    fallback_counter_stop.set()
                    fallback_counter_thread.join()
                    
                    if fallback_counter_data['final_time']:
                        elapsed_minutes = fallback_counter_data['final_time'] // 60
                        elapsed_seconds = fallback_counter_data['final_time'] % 60
                        if elapsed_minutes > 0:
                            time_str = f"{elapsed_minutes}m {elapsed_seconds:02d}s"
                        else:
                            time_str = f"{elapsed_seconds:02d}s"
                        print(f"\r‚úÖ Fallback model responded in {Colors.GREEN}{Colors.BOLD}{time_str}{Colors.RESET}")
                    
                    if fallback_result.returncode != 0:
                        print(f"‚ùå Error calling fallback model: {fallback_result.stderr}")
                        return ""
                    
                    # Filter fallback output the same way
                    fallback_output_lines = fallback_result.stdout.strip().split('\n')
                    fallback_filtered_lines = []
                    fallback_yaml_started = False
                    
                    for line in fallback_output_lines:
                        if 'agent_id:' in line.lower() or 'draft_prompt:' in line.lower():
                            fallback_yaml_started = True
                        elif fallback_yaml_started:
                            fallback_filtered_lines.append(line)
                    
                    return '\n'.join(fallback_filtered_lines)
                    
                except subprocess.TimeoutExpired:
                    fallback_counter_stop.set()
                    fallback_counter_thread.join()
                    print(f"‚ùå Fallback model {fallback_model} also timed out after {agent_timeout}s")
                    return ""
                except Exception as e:
                    fallback_counter_stop.set()
                    fallback_counter_thread.join()
                    print(f"‚ùå Error calling fallback model: {e}")
                    return ""
            elif agent_name == 'claude':
                print("‚ÑπÔ∏è  Claude automatically tried fallback model internally")
                return ""
            else:
                print("‚ö†Ô∏è  No fallback model configured")
                return ""
        except FileNotFoundError:
            counter_stop.set()
            counter_thread.join()
            print(f"‚ùå '{agent_name}' command not found. Please install {agent_name} CLI.")
            return ""
        except Exception as e:
            counter_stop.set()
            counter_thread.join()
            print(f"‚ùå Error calling {agent_name}: {e}")
            return ""
    
    def parse_router_response(self, response: str) -> Dict[str, Any]:
        """Parse the YAML response from the router"""
        try:
            # Extract YAML content between markers
            yaml_start = response.find('```yaml')
            yaml_end = response.find('```', yaml_start + 7)
            
            if yaml_start == -1 or yaml_end == -1:
                raise ValueError("No YAML markers found in response")
            
            yaml_content = response[yaml_start + 7:yaml_end].strip()
            
            # Parse YAML but also extract raw draft_prompt to preserve formatting
            parsed = yaml.safe_load(yaml_content)
            
            # Extract the raw draft_prompt with preserved line breaks
            if parsed and 'draft_prompt' in parsed:
                # Find the draft_prompt section in the raw YAML
                draft_start = yaml_content.find('draft_prompt:')
                if draft_start != -1:
                    # Find the content after the >- marker
                    content_start = yaml_content.find('>-', draft_start)
                    if content_start != -1:
                        content_start = yaml_content.find('\n', content_start) + 1
                        
                        # Find the end (next YAML key or end of content)
                        lines = yaml_content[content_start:].split('\n')
                        prompt_lines = []
                        
                        for line in lines:
                            # If line doesn't start with spaces, it's a new YAML key
                            if line.strip() and not line.startswith('  '):
                                break
                            # Remove the indentation (first 2 spaces) and add to prompt
                            if line.startswith('  '):
                                prompt_lines.append(line[2:])
                            elif not line.strip():  # Empty line
                                prompt_lines.append('')
                        
                        # Join with actual line breaks
                        raw_prompt = '\n'.join(prompt_lines).strip()
                        if raw_prompt:
                            parsed['draft_prompt_raw'] = raw_prompt
            
            return parsed
            
        except (yaml.YAMLError, ValueError) as e:
            print(f"‚ùå Error parsing router response: {e}")
            return {}
    
    def show_iteration_context(self, user_problem: str, additional_context: str, iteration: int):
        """Show current session context to the user"""
        print(f"\n{Colors.BOLD}üìã CURRENT SESSION CONTEXT{Colors.RESET}")
        print("="*70)
        print(f"{Colors.BOLD}üéØ Original Problem:{Colors.RESET}")
        print(f"   {user_problem}")
        
        if additional_context:
            print(f"\n{Colors.BOLD}üîÑ Accumulated Refinements:{Colors.RESET}")
            context_lines = additional_context.split('\n')
            for line in context_lines:
                if line.strip():
                    print(f"   {line}")
        
        print(f"\n{Colors.BOLD}üìä Current Iteration:{Colors.RESET} {iteration}")
        print("="*70)
    
    def get_additional_feedback_with_context(self) -> str:
        """Get additional feedback from user with better guidance and enhanced text wrapping"""
        print(f"\n{Colors.YELLOW}üí° REFINEMENT GUIDANCE{Colors.RESET}")
        print("What you provide here will be ADDED to your original problem.")
        print("You can:")
        print("  ‚Ä¢ Add new requirements or constraints")
        print("  ‚Ä¢ Clarify existing requirements") 
        print("  ‚Ä¢ Specify what you didn't like about the current solution")
        print("  ‚Ä¢ Request different approaches or technologies")
        print("")
        print("Examples:")
        print("  - 'Make it more mobile-friendly'")
        print("  - 'Use hash routing instead of path routing'")
        print("  - 'Add error handling for network failures'")
        print("  - 'Focus more on performance optimization'")
        print("")
        
        # Force readline reconfiguration specifically for iteration feedback
        print(f"{Colors.DIM}üîß Configuring text input for optimal wrapping...{Colors.RESET}")
        self.configure_readline_for_input()
        
        return self.get_multiline_input("üìù What refinements do you want to add?")
    
    def preview_strategist_input(self, enhanced_problem: str) -> bool:
        """Show user what will be sent to Solution Strategist"""
        print(f"\n{Colors.YELLOW}üîç PREVIEW: What will be sent to Solution Strategist{Colors.RESET}")
        print("="*70)
        print(enhanced_problem)
        print("="*70)
        
        # Ask for confirmation
        while True:
            choice = input(f"\n{Colors.CYAN}Proceed with this input? (y/n): {Colors.RESET}").lower().strip()
            if choice in ['y', 'yes', '']:
                return True
            elif choice in ['n', 'no']:
                print("‚ùå Operation cancelled.")
                return False
            else:
                print("Please enter 'y' for yes or 'n' for no.")
    
    def get_execution_scope(self) -> str:
        """Ask user about execution scope: single vs per-unit"""
        print(f"\n{Colors.BOLD}üéØ EXECUTION SCOPE{Colors.RESET}")
        print("Will this solution be applied once to the entire project, or should it")
        print("be executed individually for each unit of the book?")
        print("")
        print("Examples:")
        print("‚Ä¢ Single execution: Global routing system, main CSS changes, index.html updates")
        print("‚Ä¢ Per-unit execution: Unit-specific content fixes, individual page improvements")
        print("")
        print(f"{Colors.GREEN}s{Colors.RESET} = Single execution (entire project)")
        print(f"{Colors.YELLOW}u{Colors.RESET} = Per-unit execution (template with Unit X placeholder)")
        
        while True:
            try:
                choice = input(f"\n{Colors.CYAN}Execution scope (s/u): {Colors.RESET}").strip().lower()
                if choice in ['s', 'single']:
                    return 'single'
                elif choice in ['u', 'unit', 'per-unit']:
                    return 'per-unit'
                else:
                    print(f"{Colors.RED}‚ùå Please enter 's' for single or 'u' for per-unit execution{Colors.RESET}")
            except (EOFError, KeyboardInterrupt):
                print(f"\n{Colors.YELLOW}üëã Exiting...{Colors.RESET}")
                return None
    
    def show_waiting_counter(self, stop_event: threading.Event, timeout_seconds: int = 60, counter_data: Dict = None):
        """Show a visual counter while waiting for agent response with timeout display"""
        start_time = time.time()
        last_message_length = 0
        
        while not stop_event.is_set():
            elapsed = int(time.time() - start_time)
            remaining = max(0, timeout_seconds - elapsed)
            minutes = elapsed // 60
            seconds = elapsed % 60
            
            # Create animated waiting message
            dots = '.' * ((elapsed % 3) + 1)
            if minutes > 0:
                time_str = f"{minutes}m {seconds:02d}s"
            else:
                time_str = f"{seconds:02d}s"
            
            # Show timeout information
            remaining_minutes = remaining // 60
            remaining_seconds = remaining % 60
            if remaining_minutes > 0:
                timeout_str = f"{remaining_minutes}m {remaining_seconds:02d}s left"
            else:
                timeout_str = f"{remaining_seconds}s left"
            
            message = f"‚è≥ Waiting for response{dots} [{time_str}] (timeout: {timeout_str})"
            
            # Always clear more space than needed to handle dots changing from 3 to 1
            clear_space = max(last_message_length, len(message), 70)  # Ensure enough space for timeout
            clear_line = '\r' + ' ' * clear_space + '\r'
            print(clear_line + message, end='', flush=True)
            last_message_length = len(message)
            
            time.sleep(1)
        
        # Store final elapsed time for caller to use
        final_elapsed = int(time.time() - start_time)
        if counter_data is not None:
            counter_data['final_time'] = final_elapsed
    
    def get_additional_feedback(self) -> str:
        """Legacy method - kept for compatibility"""
        return self.get_additional_feedback_with_context()
    
    def show_final_message(self, satisfied: bool, prompt_id: str):
        """Show final success/completion message"""
        print("\n" + "="*70)
        if satisfied:
            print("‚úÖ PROMPT GENERATED SUCCESSFULLY!")
            print(f"üìÅ Prompt saved with ID: {prompt_id}")
            print(f"üìÇ Location: src/conf/agent_prompts.yaml")
        else:
            print("üîÑ PROMPT SAVED FOR REFINEMENT")
            print(f"üìÅ Prompt saved with ID: {prompt_id}")
            print(f"üìÇ Status: needs_refinement in src/conf/agent_prompts.yaml")
        print("="*70)
    
    def run(self):
        """Main CLI execution flow"""
        try:
            self.print_header()
            
            # Step 1: Get user problem
            user_problem = self.get_multiline_input("Describe your problem or task:")
            if not user_problem:
                print("üëã Session cancelled by user.")
                return
            
            # Step 1.5: Get execution scope
            execution_scope = self.get_execution_scope()
            if execution_scope is None:
                print("üëã Session cancelled by user.")
                return
            
            # Step 2: Call router agent
            router_response = self.call_router_agent(user_problem, execution_scope)
            if not router_response:
                print("‚ùå Failed to get router response.")
                return
            
            # Step 3: Parse response
            decision = self.parse_router_response(router_response)
            if not decision:
                print("‚ùå Failed to parse router response.")
                return
            
            # Step 4: Interactive loop with Solution Strategist
            satisfied = None
            additional_context = ""
            iteration = 1
            
            while True:
                print(f"\n{Colors.BOLD}{'='*70}")
                print(f"ITERATION {iteration}")
                print(f"{'='*70}{Colors.RESET}")
                
                # Display results and get feedback
                satisfied = self.display_results(decision, user_problem)
                
                # Handle different responses
                if satisfied is None:  # Cancellation
                    print("üëã Session cancelled by user.")
                    return
                elif satisfied == 'modify':  # Interactive mode
                    print(f"\n{Colors.CYAN}üîÑ Entering interactive refinement mode...{Colors.RESET}")
                    
                    # Show current context to user
                    self.show_iteration_context(user_problem, additional_context, iteration)
                    
                    # Get additional context from user with better guidance
                    additional_feedback = self.get_additional_feedback_with_context()
                    if not additional_feedback:
                        print("üëã Session cancelled by user.")
                        return
                    
                    # Add this feedback to accumulated context
                    if additional_context:
                        additional_context += f"\n\nIteration {iteration}: {additional_feedback}"
                    else:
                        additional_context = additional_feedback
                    
                    # Create enhanced problem description with context
                    enhanced_problem = f"{user_problem}\n\nAdditional context and refinements:\n{additional_context}"
                    
                    # Show what will be sent to Solution Strategist and get confirmation
                    if not self.preview_strategist_input(enhanced_problem):
                        print("üëã Session cancelled by user.")
                        return
                    
                    # Call Solution Strategist again with enhanced problem
                    router_response = self.call_router_agent(enhanced_problem, execution_scope)
                    if not router_response:
                        print("‚ùå Failed to get router response.")
                        return
                    
                    # Parse new response
                    decision = self.parse_router_response(router_response)
                    if not decision:
                        print("‚ùå Failed to parse router response.")
                        return
                    
                    iteration += 1
                    satisfied = None  # Continue the loop
                elif satisfied == False:  # Not satisfied but don't want to interact
                    # Get final feedback and exit loop
                    final_feedback = self.get_additional_feedback()
                    if final_feedback:
                        additional_context += f"\nFinal feedback: {final_feedback}"
                    break
                else:  # satisfied == True
                    break
            
            # Step 5: Save prompt
            final_satisfied = satisfied if satisfied is not None and satisfied != 'modify' else False
            print(f"\n{Colors.CYAN}üíæ Saving prompt...{Colors.RESET}")
            prompt_id = self.save_prompt_entry(user_problem, decision, final_satisfied, additional_context, execution_scope)
            
            # Step 6: Show final message
            if prompt_id:
                self.show_final_message(final_satisfied, prompt_id)
                
        except KeyboardInterrupt:
            print("\nüëã Session cancelled by user.")
        except Exception as e:
            print(f"\n‚ùå Unexpected error: {e}")
            print("\nüîç Stack trace (last 3 calls from our code):")
            import traceback
            tb_lines = traceback.format_exc().split('\n')
            # Filter for lines that contain our code (not system/library code)
            our_code_lines = [line for line in tb_lines if 'agent_router' in line or 'learn-cloud' in line]
            for line in our_code_lines[-6:]:  # Show last 6 relevant lines
                if line.strip():
                    print(f"    {line}")

def main():
    """Entry point"""
    router = AgentRouterCLI()
    router.run()

if __name__ == "__main__":
    main()