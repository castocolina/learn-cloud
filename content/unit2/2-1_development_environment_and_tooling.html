<div class="container">
    <div class="page-header">
        <h1>2.1: Development Environment & Tooling</h1>
    </div>

    <p class="lead">Welcome to Unit 2! Having built a solid foundation in Python, we now pivot to another giant of the cloud-native world: <strong>Go</strong>. As an experienced developer, you'll appreciate Go's opinionated and pragmatic design, which prioritizes simplicity, performance, and concurrency. This topic guides you through setting up a professional Go development environment, highlighting the similarities and key differences from the Python ecosystem.</p>

    <hr/>

    <h2><i class="bi bi-question-circle"></i> Why Go for the Cloud?</h2>
    <p>Go was designed at Google to solve problems of scale and concurrency. Its strengths make it a perfect fit for cloud-native services:</p>
    <ul>
        <li><strong><i class="bi bi-speedometer2"></i> Performance:</strong> Go is a compiled language that compiles directly to machine code, offering performance that is an order of magnitude faster than interpreted languages like Python.</li>
        <li><strong><i class="bi bi-diagram-3"></i> Concurrency Built-in:</strong> Go's first-class support for concurrency with goroutines and channels makes it incredibly easy to build highly concurrent services that can handle thousands of simultaneous requests efficiently.</li>
        <li><strong><i class="bi bi-box-seam"></i> Static Binaries:</strong> Go compiles your application and all its dependencies into a single, statically-linked binary. This makes deployment trivial and is a massive advantage in containerized environments, leading to incredibly small and secure Docker images.</li>
        <li><strong><i class="bi bi-code-slash"></i> Simplicity and Readability:</strong> Go has a small, simple syntax and a strong emphasis on readability and idiomatic code, enforced by its built-in tooling.</li>
    </ul>

    <div class="text-center my-4">
        <pre class="mermaid">
            graph TD
                A["Go Language"] --> B("Performance");
                A --> C("Concurrency");
                A --> D("Static Binaries");
                A --> E("Simplicity");
        </pre>
        <small class="text-muted">Diagram: Core Strengths of Go</small>
    </div>

    <hr/>

    <h2><i class="bi bi-tools"></i> 1. Setup: Installing the Go Toolchain</h2>
    <p>
        Unlike Python's need for external tools like `pyenv`, Go's toolchain is self-contained and manages different versions effectively. The official installation instructions can be found at <a href="https://go.dev/doc/install" target="_blank">go.dev</a>. The installer handles setting up the `GOROOT` (where the Go SDK is located) and adding the `GOPATH/bin` directory to your system's `PATH`.
    </p>
    <p>
        For developers who need to switch between multiple Go versions frequently, tools like <a href="https://github.com/go-nv/goenv" target="_blank" rel="noopener noreferrer"><code>goenv</code></a> exist, providing a similar experience to Python's `pyenv`.
    </p>

    <hr/>

    <h2><i class="bi bi-journal-code"></i> 2. Dependency Management with Go Modules</h2>
    <p>
        Go's official dependency management system is <strong>Go Modules</strong>. This is the equivalent of Python's Poetry or pip/venv, but it's built directly into the Go toolchain. It addresses dependency management with two key files: <code>go.mod</code> and <code>go.sum</code>.
    </p>
    <ul>
        <li><strong><code>go.mod</code>:</strong> The heart of the module. It declares the module's path (its unique name), the Go version it's compatible with, and its direct dependencies. This is analogous to <code>pyproject.toml</code>.</li>
        <li><strong><code>go.sum</code>:</strong> A lock file containing the cryptographic checksums of all direct and indirect dependencies. This ensures that every build is completely reproducible and secure. This is analogous to <code>poetry.lock</code>.</li>
    </ul>

    <h4>Getting Started with Go Modules</h4>
    <p>Starting a new project is straightforward. Unlike Python, you don't need to create a virtual environment; Go handles this implicitly.</p>
    <pre><code class="language-bash">
# Create a new directory for your project
mkdir my-go-service
cd my-go-service

# Initialize a new module
# The module path is typically your repository path (e.g., example.com/user/repo)
go mod init example.com/my-go-service

# Create a main file
touch main.go
    </code></pre>
    <p>To add a dependency, you can use `go get` or simply add an `import` statement to your code. The Go toolchain will automatically download the module and update `go.mod` and `go.sum` the next time you build or run `go mod tidy`.</p>
    <pre><code class="language-go">
// main.go
package main

import (
    "fmt"
    "github.com/gin-gonic/gin" // Importing a new dependency
)

func main() {
    fmt.Println("Starting Go service...")
}
    </code></pre>
    <p>Now, run `go mod tidy` to clean up and add the new dependency:</p>
    <pre><code class="language-bash">
# This command synchronizes your go.mod file with your source code
go mod tidy
    </code></pre>
    <p>This command will find the `gin-gonic/gin` import, download the module, and add it to your `go.mod` and `go.sum` files.</p>

    <hr/>

    <h2><i class="bi bi-folder2-open"></i> 3. Standard Project Structure</h2>
    <p>
        The Go community has established a <a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener noreferrer">standard project layout</a> that is widely adopted. While not strictly enforced by the compiler, following it makes projects understandable and maintainable.
    </p>
    <div class="text-center my-4">
        <pre class="mermaid">
            graph TD
                A["Project Root"] --> B["go.mod"];
                A --> C["go.sum"];
                A --> D["/cmd"];
                A --> E["/internal"];
                A --> F["/pkg"];
                A --> G["/api"];

                D --> D1["my-app/main.go"];
                E --> E1[".../internal/database"];
                E --> E2[".../internal/auth"];
                F --> F1[".../pkg/billing"];
                G --> G1[".../api/v1/api.proto"];

                subgraph "Application"
                    D["/cmd - Application Entrypoints"]
                end
                subgraph "Private Code"
                    E["/internal - Private application and library code"]
                end
                subgraph "Public Code"
                    F["/pkg - Public library code, ok to be used by others"]
                end
                subgraph "API Definitions"
                    G["/api - Protobuf definitions, JSON schemas"]
                end
        </pre>
        <small class="text-muted">Diagram: Standard Go Project Layout</small>
    </div>
    <ul>
        <li><code>/cmd</code>: Main applications for your project. The directory name should match the executable you want to build.</li>
        <li><code>/internal</code>: Private application and library code. It's a Go compiler feature that code in `internal` cannot be imported by other projects.</li>
        <li><code>/pkg</code>: Public library code that's okay to be imported by other projects.</li>
    </ul>

    <hr/>

    <h2><i class="bi bi-pc-display"></i> 4. IDE Integration: VS Code and GoLand</h2>
    <p>A good IDE is essential for productivity. As with Python, VS Code and a JetBrains IDE are the top contenders.</p>
    <ul>
        <li><strong>Visual Studio Code:</strong> The official <a href="https://marketplace.visualstudio.com/items?itemName=golang.Go" target="_blank" rel="noopener noreferrer">Go extension</a> provides excellent support, including IntelliSense, code navigation, debugging, and integration with the Go language server (<code>gopls</code>), which provides most of the language-specific features.</li>
        <li><strong>GoLand:</strong> The professional Go IDE from JetBrains. It offers a more "batteries-included" experience with deep code understanding, powerful refactoring tools, and an integrated debugger.</li>
    </ul>

    <hr/>

    <h2><i class="bi bi-box"></i> 5. Containerization with Docker: The Multi-Stage Advantage</h2>
    <p>
        This is where Go truly shines in a cloud-native context. Because Go compiles to a single static binary, we can use a <strong>multi-stage Docker build</strong> to create incredibly small and secure container images.
    </p>
    <div class="text-center my-4">
        <pre class="mermaid">
            graph TD
                subgraph "Stage 1: Builder"
                    A["Go Base Image (e.g., golang:1.22)"] --> B["Source Code"];
                    B --> C["go build"];
                    C --> D["Static Binary"];
                end

                subgraph "Stage 2: Final Image"
                    E["Minimal Base Image (e.g., scratch or alpine)"]
                    D -- "Copied to" --> E;
                end

                E --> F["Final, Small Docker Image"];

                style A fill:#ccf,stroke:#333,stroke-width:2px
                style E fill:#cfc,stroke:#333,stroke-width:2px
        </pre>
        <small class="text-muted">Diagram: Go Multi-Stage Docker Build</small>
    </div>
    <p>Here is a best-practice <code>Dockerfile</code> for a Go application:</p>
    <pre><code class="language-dockerfile">
# --- Stage 1: Build the binary ---
# Use a specific version for reproducible builds
FROM golang:1.22-alpine AS builder

# Set the working directory
WORKDIR /app

# Copy the Go module files and download dependencies to leverage Docker cache
COPY go.mod go.sum ./
RUN go mod download

# Copy the rest of the source code
COPY . .

# Build the application, creating a static binary
# CGO_ENABLED=0 is important for creating a static binary without C dependencies
# -ldflags="-w -s" strips debugging information, reducing the binary size
RUN CGO_ENABLED=0 GOOS=linux go build -a -ldflags="-w -s" -o /main ./cmd/my-go-service

# --- Stage 2: Create the final, minimal image ---
# Use the 'scratch' image which is completely empty for maximum security and minimum size
FROM scratch

# Copy the static binary from the builder stage
COPY --from=builder /main /main

# (Optional) Copy any other necessary files, like configuration or certificates
# COPY --from=builder /app/config.json /config.json

# Expose the port the application runs on
EXPOSE 8080

# Set the entrypoint for the container
ENTRYPOINT ["/main"]
    </code></pre>
    <p>This process results in a final image that is often just 10-20 MB in size and contains nothing but your application binary, drastically reducing the attack surface and improving deployment speed.</p>

    <hr/>

    <h2>Conclusion</h2>
    <p>You have now configured a professional Go development environment. By understanding Go's built-in tooling, dependency management with modules, standard project structure, and the power of multi-stage Docker builds, you are well-equipped to start building high-performance, cloud-native services. The emphasis on simplicity and self-contained tooling provides a refreshingly different experience from the Python ecosystem, with unique advantages for containerized deployments.</p>
</div>