<h2>Study Aids: Advanced Backend Topics</h2>

<div class="card mb-4">
    <div class="card-header">
        Key Takeaways
    </div>
    <div class="card-body">
        <ul>
            <li><strong>Beyond REST:</strong> For complex microservice systems, advanced communication patterns like event-driven architecture and gRPC are essential for scalability and performance.</li>
            <li><strong>Event-Driven Architecture (EDA):</strong> Using a message broker like RabbitMQ allows services to communicate asynchronously. This decouples services, improves fault tolerance, and enables independent scaling of producers and consumers.</li>
            <li><strong>gRPC for Performance:</strong> gRPC is a high-performance RPC framework ideal for internal, synchronous communication. It uses HTTP/2 and Protocol Buffers for efficient, strongly-typed, and low-latency connections.</li>
            <li><strong>Protobuf as the Contract:</strong> Protocol Buffers (Protobuf) provide the Interface Definition Language (IDL) for gRPC, allowing you to define service contracts and generate code in any supported language, ensuring consistency between services.</li>
            <li><strong>Choose the Right Tool:</strong> The choice between synchronous patterns (like REST or gRPC) and asynchronous ones (like message queues) is a critical architectural decision based on the specific requirements of the service interaction.</li>
        </ul>
    </div>
</div>

<div id="flashcards-section">
    <div class="flashcards-container">

        <div class="flashcard" onclick="this.classList.toggle('flipped')">
            <div class="flashcard-front">
                <button type="button" class="btn btn-sm btn-outline-secondary view-diagram-btn" data-bs-toggle="modal" data-bs-target="#mermaidModal" title="Expand View">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <h4>Question</h4>
                <p>What are three primary benefits of an Event-Driven Architecture (EDA)?</p>
            </div>
            <div class="flashcard-back">
                <button type="button" class="btn btn-sm btn-outline-secondary view-diagram-btn" data-bs-toggle="modal" data-bs-target="#mermaidModal" title="Expand View">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <h4>Answer</h4>
                <p>1. <strong>Decoupling:</strong> Services don't need direct knowledge of each other. <br>2. <strong>Scalability:</strong> Producers and consumers can be scaled independently. <br>3. <strong>Resilience:</strong> If a consumer service is temporarily unavailable, messages can be queued and processed later.</p>
            </div>
        </div>

        <div class="flashcard" onclick="this.classList.toggle('flipped')">
            <div class="flashcard-front">
                <button type="button" class="btn btn-sm btn-outline-secondary view-diagram-btn" data-bs-toggle="modal" data-bs-target="#mermaidModal" title="Expand View">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <h4>Question</h4>
                <p>What is gRPC and what is its typical use case in a microservices architecture?</p>
            </div>
            <div class="flashcard-back">
                <button type="button" class="btn btn-sm btn-outline-secondary view-diagram-btn" data-bs-toggle="modal" data-bs-target="#mermaidModal" title="Expand View">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <h4>Answer</h4>
                <p>gRPC is a high-performance, open-source RPC framework. Its typical use case is for synchronous, low-latency, internal communication between microservices where a strongly-typed API contract is important.</p>
            </div>
        </div>

        <div class="flashcard" onclick="this.classList.toggle('flipped')">
            <div class="flashcard-front">
                <button type="button" class="btn btn-sm btn-outline-secondary view-diagram-btn" data-bs-toggle="modal" data-bs-target="#mermaidModal" title="Expand View">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <h4>Question</h4>
                <p>What is the role of a <code>.proto</code> file in gRPC development?</p>
            </div>
            <div class="flashcard-back">
                <button type="button" class="btn btn-sm btn-outline-secondary view-diagram-btn" data-bs-toggle="modal" data-bs-target="#mermaidModal" title="Expand View">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <h4>Answer</h4>
                <p>The <code>.proto</code> file serves as the Interface Definition Language (IDL). It defines the RPC services, their methods, and the structure of the request and response messages using Protocol Buffers syntax. It is the single source of truth for the API contract.</p>
            </div>
        </div>

        <div class="flashcard" onclick="this.classList.toggle('flipped')">
            <div class="flashcard-front">
                <button type="button" class="btn btn-sm btn-outline-secondary view-diagram-btn" data-bs-toggle="modal" data-bs-target="#mermaidModal" title="Expand View">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <h4>Question</h4>
                <p>What command is used to generate Go code from a <code>.proto</code> file for gRPC?</p>
            </div>
            <div class="flashcard-back">
                <button type="button" class="btn btn-sm btn-outline-secondary view-diagram-btn" data-bs-toggle="modal" data-bs-target="#mermaidModal" title="Expand View">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <h4>Answer</h4>
                <p>The <code>protoc</code> compiler is used with the Go plugins: <code>protoc --go_out=. --go-grpc_out=. your_file.proto</code>. This generates both the message struct code and the gRPC client/server code.</p>
            </div>
        </div>

        <div class="flashcard" onclick="this.classList.toggle('flipped')">
            <div class="flashcard-front">
                <button type="button" class="btn btn-sm btn-outline-secondary view-diagram-btn" data-bs-toggle="modal" data-bs-target="#mermaidModal" title="Expand View">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <h4>Question</h4>
                <p>Contrast the use cases for RabbitMQ and gRPC in a microservices architecture.</p>
            </div>
            <div class="flashcard-back">
                <button type="button" class="btn btn-sm btn-outline-secondary view-diagram-btn" data-bs-toggle="modal" data-bs-target="#mermaidModal" title="Expand View">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <h4>Answer</h4>
                <p><strong>RabbitMQ</strong> is for <strong>asynchronous</strong>, event-driven communication to decouple services and offload long-running tasks. <br><strong>gRPC</strong> is for <strong>synchronous</strong>, request/response communication that requires high performance and a strict, typed API contract between internal services.</p>
            </div>
        </div>

    </div>
</div>
