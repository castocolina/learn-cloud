<div class="container">
    <div class="page-header">
        <h1>2.7: Advanced Backend Topics</h1>
    </div>

    <p class="lead">As microservice architectures become more complex, simple request/response communication with REST is not always the best fit. To build truly scalable and resilient systems, Go developers leverage advanced patterns like event-driven architecture and high-performance RPC frameworks. This topic explores two cornerstones of modern backend communication: using message queues for asynchronous processing and gRPC with Protocol Buffers for efficient inter-service communication.</p>

    <hr/>

    <!-- Event-Driven Architecture -->
    <h2><i class="bi bi-lightning-charge"></i> 1. Event-Driven Architecture with Message Queues</h2>
    <p>
        <strong>Event-driven architecture (EDA)</strong> is a powerful paradigm where services communicate asynchronously by producing and consuming events. This decouples services, allowing them to evolve and scale independently. The central component of this architecture is a <strong>message queue</strong> (or message broker).
    </p>

    <div class="text-center my-4">
        <pre class="mermaid">
            graph TD
                Producer["Service A (Producer)"] -- "Publishes Event" --> MessageQueue["Message Queue"];
                MessageQueue -- "Delivers Event" --> Consumer1["Service B (Consumer)"];
                MessageQueue -- "Delivers Event" --> Consumer2["Service C (Consumer)"];
        </pre>
        <small class="text-muted">Diagram: Asynchronous Communication in an Event-Driven Architecture</small>
    </div>

    <h3>RabbitMQ with Go</h3>
    <p>
        <a href="https://www.rabbitmq.com/" target="_blank">RabbitMQ</a> is a mature and widely used message broker. The official Go client library is robust and provides all the features needed to interact with it.
    </p>

    <h4>Setup: Running RabbitMQ with Docker</h4>
    <pre><code class="language-bash">
docker run -d --hostname my-rabbit --name some-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management-alpine
    </code></pre>
    <p>The management UI is available at <a href="http://localhost:15672" target="_blank">http://localhost:15672</a> (user: `guest`, pass: `guest`).</p>

    <h4>Go Client Installation</h4>
    <pre><code class="language-bash">go get github.com/rabbitmq/amqp091-go</code></pre>

    <h4>Producer Example (<code>producer/main.go</code>)</h4>
    <p>This program will connect to RabbitMQ and send a message every second.</p>
    <pre><code class="language-go">
package main

import (
    "context"
    "log"
    "time"

    amqp "github.com/rabbitmq/amqp091-go"
)

func failOnError(err error, msg string) {
    if err != nil {
        log.Panicf("%s: %s", msg, err)
    }
}

func main() {
    conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
    failOnError(err, "Failed to connect to RabbitMQ")
    defer conn.Close()

    ch, err := conn.Channel()
    failOnError(err, "Failed to open a channel")
    defer ch.Close()

    q, err := ch.QueueDeclare(
        "task_queue", // name
        true,         // durable
        false,        // delete when unused
        false,        // exclusive
        false,        // no-wait
        nil,          // arguments
    )
    failOnError(err, "Failed to declare a queue")

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    body := "Hello, this is a task!"
    err = ch.PublishWithContext(ctx,
        "",           // exchange
        q.Name,       // routing key
        false,        // mandatory
        false,        // immediate
        amqp.Publishing{
            DeliveryMode: amqp.Persistent,
            ContentType:  "text/plain",
            Body:         []byte(body),
        })
    failOnError(err, "Failed to publish a message")
    log.Printf(" [x] Sent %s\n", body)
}
    </code></pre>

    <h4>Consumer Example (<code>consumer/main.go</code>)</h4>
    <p>This program will connect to the same queue and process messages as they arrive.</p>
    <pre><code class="language-go">
package main

import (
    "log"

    amqp "github.com/rabbitmq/amqp091-go"
)

func failOnError(err error, msg string) {
    if err != nil {
        log.Panicf("%s: %s", msg, err)
    }
}

func main() {
    conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
    failOnError(err, "Failed to connect to RabbitMQ")
    defer conn.Close()

    ch, err := conn.Channel()
    failOnError(err, "Failed to open a channel")
    defer ch.Close()

    q, err := ch.QueueDeclare(
        "task_queue", // name
        true,         // durable
        false,        // delete when unused
        false,        // exclusive
        false,        // no-wait
        nil,          // arguments
    )
    failOnError(err, "Failed to declare a queue")

    msgs, err := ch.Consume(
        q.Name, // queue
        "",     // consumer
        true,   // auto-ack
        false,  // exclusive
        false,  // no-local
        false,  // no-wait
        nil,    // args
    )
    failOnError(err, "Failed to register a consumer")

    var forever chan struct{}

    go func() {
        for d := range msgs {
            log.Printf("Received a message: %s", d.Body)
        }
    }()

    log.Printf(" [*] Waiting for messages. To exit press CTRL+C")
    &lt;-forever
}
    </code></pre>

    <hr/>

    <!-- gRPC -->
    <h2><i class="bi bi-braces-asterisk"></i> 2. Working with Protobuf for gRPC Communication</h2>
    <p>
        For high-performance, low-latency internal communication between microservices, <strong>gRPC</strong> is often preferred over REST. It uses HTTP/2 for transport and <strong>Protocol Buffers (Protobuf)</strong> as its interface definition language (IDL), enabling efficient binary serialization and strongly-typed contracts.
    </p>

    <div class="text-center my-4">
        <pre class="mermaid">
            graph TD
                A["Client Application"] --> B["Client Stub (Generated)"];
                B -- "RPC Call (Binary Protobuf)" --> C["Network (HTTP/2)"];
                C --> D["Server (Generated Skeleton)"];
                D --> E["Service Implementation"];
                E -- "Response (Binary Protobuf)" --> D;
                D --> C;
                C --> B;
                B --> A;
        </pre>
        <small class="text-muted">Diagram: gRPC Communication Flow</small>
    </div>

    <h3>Protocol Buffers (Protobuf)</h3>
    <p>
        You define your services and message structures in a <code>.proto</code> file. This file is a language-agnostic contract that can be used to generate client and server code in any supported language, including Go.
    </p>

    <h4>Example <code>.proto</code> file (<code>proto/greeter.proto</code>)</h4>
    <pre><code class="language-protobuf">
syntax = "proto3";

package greeter;

option go_package = "example.com/my-go-service/proto";

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
    </code></pre>

    <h4>Compiling Protobuf to Go</h4>
    <p>First, install the `protoc` compiler and the Go plugins:</p>
    <pre><code class="language-bash">
# Install protoc (e.g., on macOS: brew install protobuf)

# Install the Go plugins
go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2

# Ensure your PATH includes the Go bin directory
export PATH="$PATH:$(go env GOPATH)/bin"
    </code></pre>
    <p>Then, compile your <code>.proto</code> file:</p>
    <pre><code class="language-bash">
protoc --go_out=. --go_opt=paths=source_relative \
    --go-grpc_out=. --go-grpc_opt=paths=source_relative \
    proto/greeter.proto
    </code></pre>
    <p>This generates <code>greeter.pb.go</code> and <code>greeter_grpc.pb.go</code> inside the `proto` directory.</p>

    <h4>gRPC Server Example (<code>server/main.go</code>)</h4>
    <pre><code class="language-go">
package main

import (
    "context"
    "log"
    "net"

    pb "example.com/my-go-service/proto" // Import generated code
    "google.golang.org/grpc"
)

// server is used to implement greeter.GreeterServer.
type server struct {
    pb.UnimplementedGreeterServer
}

// SayHello implements greeter.GreeterServer
func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
    log.Printf("Received: %v", in.GetName())
    return &pb.HelloReply{Message: "Hello " + in.GetName()}, nil
}

func main() {
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    s := grpc.NewServer()
    pb.RegisterGreeterServer(s, &server{})
    log.Printf("server listening at %v", lis.Addr())
    if err := s.Serve(lis); err != nil {
        log.Fatalf("failed to serve: %v", err)
    }
}
    </code></pre>

    <h4>gRPC Client Example (<code>client/main.go</code>)</h4>
    <pre><code class="language-go">
package main

import (
    "context"
    "log"
    "os"
    "time"

    pb "example.com/my-go-service/proto"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

func main() {
    conn, err := grpc.Dial("localhost:50051", grpc.WithTransportCredentials(insecure.NewCredentials()))
    if err != nil {
        log.Fatalf("did not connect: %v", err)
    }
    defer conn.Close()
    c := pb.NewGreeterClient(conn)

    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel()

    name := "world"
    if len(os.Args) > 1 {
        name = os.Args[1]
    }

    r, err := c.SayHello(ctx, &pb.HelloRequest{Name: name})
    if err != nil {
        log.Fatalf("could not greet: %v", err)
    }
    log.Printf("Greeting: %s", r.GetMessage())
}
    </code></pre>

</div>
