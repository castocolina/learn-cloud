<div class="container">
    <div class="page-header">
        <h1>2.5 Core Backend Concepts</h1>
    </div>

    <p class="lead">With a grasp of Go's fundamentals, we can now apply them to the core tasks of backend development: structuring application logic and managing data. This topic explores how Go approaches object-oriented principles and demonstrates how to interact with the essential data stores of modern applications: relational (SQL) and NoSQL databases.</p>

    <hr/>

    <!-- OOP in Go -->
    <h2>1. Structs, Interfaces, and Object-Oriented Principles in Go</h2>
    <p>
        Go is not a traditional object-oriented programming language. It doesn't have classes, inheritance, or keywords like `protected` or `private`. However, it achieves the same goals of OOP through a simpler, more flexible set of features based on composition.
    </p>
    <ul>
        <li><strong>Encapsulation:</strong> Go uses <code>structs</code> to hold data (state) and <code>methods</code> (functions with a receiver) to define behavior on that data. Visibility (public/private) is controlled by capitalization: a name starting with a capital letter is exported (public), while a lowercase name is unexported (private to the package).</li>
        <li><strong>Composition (instead of Inheritance):</strong> Go uses struct embedding to achieve code reuse. You embed one struct within another, and the methods of the embedded struct are promoted to the containing struct.</li>
        <li><strong>Polymorphism:</strong> Achieved through interfaces, as covered in the previous topic.</li>
    </ul>

    <pre><code class="language-go">
package main

import "fmt"

// User struct holds the data.
type User struct {
    ID       int
    Username string
    email    string // unexported (private) field
}

// Greet is a method associated with the User struct.
// It receives a copy of the User instance.
func (u User) Greet() {
    fmt.Printf("Hello, my name is %s\n", u.Username)
}

// SetEmail is a method that modifies the User struct.
// It must receive a pointer (*User) to modify the original instance.
func (u *User) SetEmail(email string) {
    u.email = email
}

func main() {
    user := User{ID: 1, Username: "gopher"}
    user.Greet()
    user.SetEmail("gopher@example.com")
    fmt.Printf("User details: %+v\n", user)
}
    </code></pre>

    <hr/>

    <!-- Relational Databases -->
    <h2>2. Working with Relational Databases (SQL)</h2>
    <p>Relational databases like PostgreSQL remain a critical part of many systems. Go provides excellent support for SQL databases through its standard library and third-party ORMs.</p>

    <h4>Setup: Running PostgreSQL with Docker</h4>
    <pre><code class="language-bash">
docker run --name postgres-db -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres:15-alpine
    </code></pre>

    <h3>Direct DB Access with `database/sql`</h3>
    <p>
        The standard library's <code>database/sql</code> package provides a generic, clean API for working with SQL databases. You use it in conjunction with a specific database driver.
    </p>
    <p>Install the PostgreSQL driver:</p>
    <pre><code class="language-bash">go get github.com/lib/pq</code></pre>

    <pre><code class="language-go">
package main

import (
    "database/sql"
    "fmt"
    "log"

    _ "github.com/lib/pq" // The PostgreSQL driver, imported for its side effects
)

func main() {
    connStr := "user=postgres password=mysecretpassword dbname=postgres sslmode=disable"
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close() // Ensure the connection is closed when main exits

    // It's a good practice to ping the database to ensure the connection is alive
    if err = db.Ping(); err != nil {
        log.Fatal(err)
    }

    fmt.Println("Successfully connected to PostgreSQL!")

    // Example: Querying for a single row
    var username string
    var email string
    // Use $1, $2 etc. for query parameters to prevent SQL injection
    err = db.QueryRow("SELECT username, email FROM users WHERE id = $1", 1).Scan(&username, &email)
    if err != nil {
        if err == sql.ErrNoRows {
            fmt.Println("No user found with that ID")
        } else {
            log.Fatal(err)
        }
    } else {
        fmt.Printf("Found user: %s, Email: %s\n", username, email)
    }
}
    </code></pre>

    <h3>Relational Databases with an ORM (GORM)</h3>
    <p>
        An Object-Relational Mapper (ORM) like <a href="https://gorm.io/" target="_blank">GORM</a> can significantly speed up development by abstracting away SQL. It maps Go structs to database tables.
    </p>
    <p>Install GORM and its PostgreSQL driver:</p>
    <pre><code class="language-bash">go get -u gorm.io/gorm
go get -u gorm.io/driver/postgres</code></pre>

    <pre><code class="language-go">
package main

import (
    "fmt"
    "log"

    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

// GORM model - a struct with GORM tags
type Product struct {
    gorm.Model // Includes ID, CreatedAt, UpdatedAt, DeletedAt
    Code  string
    Price uint
}

func main() {
    dsn := "host=localhost user=postgres password=mysecretpassword dbname=postgres port=5432 sslmode=disable"
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("Failed to connect to database")
    }

    // Migrate the schema
    db.AutoMigrate(&Product{})

    // Create a new product
    db.Create(&Product{Code: "D42", Price: 100})

    // Read a product
    var product Product
    db.First(&product, 1) // find product with integer primary key
    fmt.Printf("Found product: %+v\n", product)

    db.First(&product, "code = ?", "D42") // find product with code D42
    fmt.Printf("Found product by code: %+v\n", product)

    // Update - update product's price to 200
    db.Model(&product).Update("Price", 200)
    fmt.Printf("Updated product: %+v\n", product)
}
    </code></pre>

    <hr/>

    <!-- NoSQL Databases -->
    <h2>3. Working with Popular NoSQL Databases</h2>

    <h3>Redis for Caching</h3>
    <p>
        <strong>Redis</strong> is the industry standard for in-memory caching. The <code>go-redis</code> library is a popular client.
    </p>
    <p>Run Redis with Docker:</p>
    <pre><code class="language-bash">docker run --name redis-db -p 6379:6379 -d redis:7-alpine</code></pre>
    <p>Install the client:</p>
    <pre><code class="language-bash">go get github.com/go-redis/redis/v8</code></pre>

    <pre><code class="language-go">
package main

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
)

var ctx = context.Background()

func main() {
    rdb := redis.NewClient(&redis.Options{
        Addr:     "localhost:6379",
        Password: "", // no password set
        DB:       0,  // use default DB
    })

    // Set a key with a 1-hour expiration
    err := rdb.Set(ctx, "user:123:session", "some_session_token", time.Hour).Err()
    if err != nil {
        panic(err)
    }

    // Get the key
    val, err := rdb.Get(ctx, "user:123:session").Result()
    if err != nil {
        panic(err)
    }
    fmt.Println("Session token:", val)
}
    </code></pre>

    <h3>MongoDB for Document Storage</h3>
    <p>
        <strong>MongoDB</strong> is a leading document database. The official Go driver is the recommended way to interact with it.
    </p>
    <p>Run MongoDB with Docker:</p>
    <pre><code class="language-bash">docker run --name mongo-db -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=example -d mongo:6</code></pre>
    <p>Install the driver:</p>
    <pre><code class="language-bash">go get go.mongodb.org/mongo-driver/mongo</code></pre>

    <pre><code class="language-go">
package main

import (
    "context"
    "fmt"
    "log"

    "go.mongodb.org/mongo-driver/bson"
    "go.mongodb.org/mongo-driver/mongo"
    "go.mongodb.org/mongo-driver/mongo/options"
)

func main() {
    client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI("mongodb://root:example@localhost:27017"))
    if err != nil {
        log.Fatal(err)
    }
    defer client.Disconnect(context.TODO())

    usersCollection := client.Database("testdb").Collection("users")

    // Insert a document
    _, err = usersCollection.InsertOne(context.TODO(), bson.D{
        {Key: "username", Value: "gopher"},
        {Key: "email", Value: "gopher@mongodb.com"},
    })
    if err != nil {
        log.Fatal(err)
    }

    // Find a document
    var result bson.M
    err = usersCollection.FindOne(context.TODO(), bson.D{{Key: "username", Value: "gopher"}}).Decode(&result)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Found document: %v\n", result)
}
    </code></pre>

</div>
