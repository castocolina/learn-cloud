
<div class="container">
    <div class="page-header">
        <h1>1.3 Code Quality and Standards</h1>
    </div>

    <p class="lead">In professional software development, writing code that works is only the first step. Writing code that is readable, maintainable, and consistent is just as critical, especially in a collaborative, cloud-native environment where multiple developers and teams will interact with the same codebase. This topic introduces the essential tools and standards for maintaining high code quality in Python.</p>

    <hr/>

    <!-- PEP 8 -->
    <h2>PEP 8: The Python Code Style Guide</h2>
    <p>
        As an experienced programmer, you know that every language has its own idioms and conventions. In Python, the foundational style guide is <strong>PEP 8</strong>. PEP stands for Python Enhancement Proposal, and PEP 8 is the specific proposal that outlines the style conventions for writing Python code.
    </p>
    <p>
        Its primary goal is to improve code readability and consistency. When everyone follows the same guidelines, it becomes much easier to read, understand, and contribute to projects. You can read the full document on the official Python website: <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank">PEP 8 -- Style Guide for Python Code</a>.
    </p>
    <p>Key areas covered by PEP 8 include:</p>
    <ul>
        <li><strong>Naming Conventions:</strong> <code>snake_case</code> for functions and variables, <code>PascalCase</code> for classes.</li>
        <li><strong>Code Layout:</strong> Use 4 spaces per indentation level, and limit lines to 79-99 characters.</li>
        <li><strong>Imports:</strong> Imports should be at the top of the file, grouped in a specific order (standard library, third-party, local application).</li>
        <li><strong>Whitespace:</strong> Use whitespace judiciously to improve readability, for example, around operators.</li>
    </ul>
    <p>
        While you could try to memorize and apply these rules manually, it's inefficient and prone to error. That's why the Python ecosystem relies on automated tools to enforce these standards.
    </p>

    <hr/>

    <!-- Black -->
    <h2>Formatting with Black</h2>
    <p>
        <strong>Black</strong> is a powerful, opinionated code formatter. It's known as "The Uncompromising Code Formatter" because it doesn't provide many configuration options. Instead, it enforces a single, consistent style for all Python code.
    </p>
    <p>
        <strong>Why is this a good thing?</strong> It completely eliminates debates over formatting. No more discussions in code reviews about comma placement or line breaks. The team agrees to use Black, and the tool handles the rest, allowing developers to focus on the logic.
    </p>

    <h4>Installation</h4>
    <p>You can install Black using pip:</p>
    <pre><code class="language-bash">pip install black</code></pre>

    <h4>Usage Example</h4>
    <p>Consider this poorly formatted Python code in a file named <code>messy_code.py</code>:</p>
    <pre><code class="language-python">
import os, sys

def my_function( a,b,c,d,e,f,g,h ):
    print("This is a very long line that will definitely exceed the standard line length limit and needs to be wrapped.")
    result = a+b+c+d+e+f+g+h
    return result

data = {'key1':'value1', 'key2':'value2'}
    </code></pre>

    <p>Now, run Black on this file from your terminal:</p>
    <pre><code class="language-bash">black messy_code.py</code></pre>

    <p>Black will reformat the file in place. The code will now look like this:</p>
    <pre><code class="language-python">
import os
import sys


def my_function(a, b, c, d, e, f, g, h):
    print(
        "This is a very long line that will definitely exceed the standard line length limit and needs to be wrapped."
    )
    result = a + b + c + d + e + f + g + h
    return result


data = {"key1": "value1", "key2": "value2"}
    </code></pre>
    <div class="alert alert-info">
        <strong>Note:</strong> Black automatically handles line wrapping, spacing, and quote normalization (preferring double quotes).
    </div>

    <hr/>

    <!-- Ruff -->
    <h2>Linting with Ruff</h2>
    <p>
        While Black handles formatting, a <strong>linter</strong> analyzes your code for potential errors, bugs, stylistic issues, and suspicious constructs. <strong>Ruff</strong> is a modern, extremely fast Python linter written in Rust. It can be over 100 times faster than older linters like Flake8 and can replace multiple tools in your toolchain.
    </p>
    <p>
        Ruff checks for a vast range of issues, including:
    </p>
    <ul>
        <li>Unused imports or variables.</li>
        <li>Undefined names.</li>
        <li>Code complexity.</li>
        <li>Security vulnerabilities.</li>
        <li>Violations of PEP 8 that are not purely about formatting.</li>
    </ul>

    <h4>Installation</h4>
    <pre><code class="language-bash">pip install ruff</code></pre>

    <h4>Usage Example</h4>
    <p>Let's create a file <code>buggy_code.py</code> with some common issues:</p>
    <pre><code class="language-python">
import sys
import os # Unused import

def process_data(data):
    if "user" in data:
        print(f"Processing data for {user}") # Undefined name 'user'
    return True

def another_function():
    pass # Unnecessary pass statement
    </code></pre>

    <p>Run Ruff to check the file:</p>
    <pre><code class="language-bash">ruff check buggy_code.py</code></pre>

    <p>Ruff will produce a clear report of the issues it found:</p>
    <pre><code class="language-text">
buggy_code.py:2:8: F401 [*] `os` imported but unused
buggy_code.py:6:38: F821 [*] Undefined name `user`
buggy_code.py:10:5: PIE790 [*] Unnecessary `pass` statement
Found 3 errors.
[*] 3 fixable with the `--fix` option.
    </code></pre>

    <h4>Automatic Fixes</h4>
    <p>
        One of Ruff's most powerful features is its ability to automatically fix many of the issues it finds. You can use the <code>--fix</code> flag:
    </p>
    <pre><code class="language-bash">ruff check --fix buggy_code.py</code></pre>
    <p>
        After running this command, Ruff will remove the unused import and the unnecessary pass statement. It cannot fix the undefined name `user` (as that's a logic error), but it has already cleaned up a significant portion of the file.
    </p>

    <hr/>

    <h2>Integration and Workflow with Pre-commit</h2>
    <p>
        To ensure these checks are run consistently without relying on developers to remember, we can automate them using <strong>pre-commit hooks</strong>. These are scripts that run automatically before a commit is created.
    </p>
    <p>
        The <a href="https://pre-commit.com/" target="_blank">pre-commit framework</a> makes this easy to manage. First, install it:
    </p>
    <pre><code class="language-bash">pip install pre-commit</code></pre>
    <p>
        Next, create a file named <code>.pre-commit-config.yaml</code> in the root of your project with the following content:
    </p>
    <pre><code class="language-yaml">
repos:
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.3.0
    hooks:
    -   id: check-yaml
    -   id: end-of-file-fixer
    -   id: trailing-whitespace
-   repo: https://github.com/psf/black
    rev: 22.10.0
    hooks:
    -   id: black
-   repo: https://github.com/charliermarsh/ruff-pre-commit
    rev: v0.0.291
    hooks:
    -   id: ruff
      args: [--fix, --exit-non-zero-on-fix]
    </code></pre>
    <p>
        Finally, install the git hooks:
    </p>
    <pre><code class="language-bash">pre-commit install</code></pre>
    <p>
        Now, every time you run <code>git commit</code>, Ruff will run first to lint and fix issues, followed by Black to format the code. If any changes are made, the commit will be aborted, allowing you to review and stage the fixes. This workflow guarantees that all code entering the repository meets the defined quality standards.
    </p>

</div>
