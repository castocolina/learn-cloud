<div class="topic-content">
    <header class="topic-header">
        <h1 class="topic-title">Unit 8.2: Secure Credential Management in CI/CD and IaC</h1>
    </header>
    <main class="topic-main">
        <section class="content-section">

    <p class="lead">We've secured our applications at runtime, but what about our development and deployment pipelines? CI/CD and Infrastructure as Code (IaC) systems are privileged and highly sensitive, as they have the credentials needed to build, test, and deploy to production. Securing this part of the lifecycle is just as critical as securing the application itself.</p>

        </section>
        <section class="content-section">
            <h2><i class="bi bi-shield-lock"></i> 1. Managing Secrets in CI/CD Pipelines</h2>
    <p>
        A CI/CD pipeline (like GitHub Actions or Jenkins) needs secrets to interact with other systems: a token to push a Docker image to a registry, an API key to deploy to a cloud provider, or a password to connect to a test database. The same rule applies here as in application code: <strong>never hardcode secrets</strong>.
    </p>

    <h4>A. GitHub Actions Secrets</h4>
    <p>
        As covered in Unit 3, GitHub Actions provides a built-in mechanism for storing secrets. They are encrypted and exposed to workflows only as environment variables. This is a good, baseline level of security.
    </p>

    <h4>B. Integrating CI/CD with Vault</h4>
    <p>
        For a more robust and centralized approach, you can integrate your CI/CD pipeline with HashiCorp Vault. This provides a single source of truth for all secrets, better auditing, and more granular control.
    </p>
    <p><strong>Workflow:</strong></p>
    <ol>
        <li>The CI/CD platform (e.g., GitHub Actions) authenticates to Vault using a trusted method, like the JWT/OIDC Auth Method.</li>
        <li>Vault validates the JWT from the CI provider and returns a short-lived Vault token.</li>
        <li>The CI job uses this token to fetch the specific secrets it needs for its tasks.</li>
    </ol>
    <p>This pattern ensures that the CI/CD platform only has access to the secrets it needs, for the duration of the job, and every action is auditable in Vault.</p>

    <div class="text-center my-4">
        <pre class="mermaid">
            graph TD
                A["GitHub Actions Job"] -- "1. Presents OIDC JWT" --> B["Vault JWT Auth Method"];
                B -- "2. Validates JWT with GitHub" --> C["GitHub OIDC Provider"];
                C -- "3. Confirms Validity" --> B;
                B -- "4. Issues short-lived Vault Token" --> A;
                A -- "5. Uses Token to fetch secrets" --> D["Vault Secrets Engine"];
                D -- "6. Returns secrets" --> A;
        </pre>
        <small class="text-muted">Diagram: GitHub Actions OIDC Authentication with Vault</small>
    </div>

        </section>
        <section class="content-section">
            <h2><i class="bi bi-key"></i> 2. Securely Passing Credentials to IaC Tools</h2>
    <p>
        IaC tools like Terraform need powerful credentials to provision infrastructure. Managing these credentials securely is critical.
    </p>

    <h4>A. Terraform Cloud / Terraform Enterprise</h4>
    <p>
        <a href="https://www.hashicorp.com/products/terraform" target="_blank">Terraform Cloud</a> and its self-hosted version, Terraform Enterprise, are the recommended way to run Terraform in a team. They provide a secure, remote environment for Terraform runs and offer several ways to manage variables and secrets, including direct integration with Vault.
    </p>

    <h4>B. Atlantis for Pull Request Automation</h4>
    <p>
        <a href="https://www.runatlantis.io/" target="_blank">Atlantis</a> is a popular open-source tool for automating Terraform via pull requests. When a developer opens a PR with Terraform changes, Atlantis automatically runs `terraform plan` and posts the output as a comment. This provides immediate feedback and allows for peer review of the proposed infrastructure changes. Once approved, a maintainer can comment `atlantis apply` to execute the changes. Atlantis itself is a service that you run, and it must be configured securely with cloud credentials.
    </p>

    <hr/>

    <h2><i class="bi bi-diagram-3"></i> 3. Connecting CI/CD to Kubernetes Securely</h2>
    <p>
        A CI/CD pipeline that deploys to Kubernetes needs a `kubeconfig` file with credentials. Storing a long-lived, admin-level `kubeconfig` as a CI/CD secret is risky. A better approach is to use short-lived, scoped credentials.
    </p>
    <p><strong>Recommended Pattern (OIDC):</strong></p>
    <ol>
        <li>Configure your Kubernetes cluster (and cloud provider) to trust your CI/CD system as an OIDC identity provider.</li>
        <li>The CI/CD job gets a short-lived OIDC token.</li>
        <li>The job exchanges this token with the cloud provider (e.g., AWS STS) for temporary cloud credentials.</li>
        <li>The job uses these temporary credentials to generate a short-lived `kubeconfig` that is only valid for the duration of the deployment.</li>
    </ol>
    <p>This pattern, while complex to set up, is the most secure as it completely avoids the use of long-lived static credentials.</p>

    <hr/>

    <h2><i class="bi bi-cloud"></i> 4. Handling AWS Credentials in CI/CD</h2>
    <p>
        The same OIDC pattern is the best practice for any CI/CD job that needs to interact with AWS.
    </p>
    <p><strong>Workflow:</strong></p>
    <ol>
        <li>Configure an OIDC identity provider in AWS IAM that trusts GitHub Actions.</li>
        <li>Create an IAM Role with the specific permissions the job needs (e.g., `s3:PutObject`, `ecs:UpdateService`).</li>
        <li>Configure the role's trust policy to allow principals from your GitHub repository to assume it.</li>
        <li>In your GitHub Actions workflow, use an official action (like `aws-actions/configure-aws-credentials`) to perform the OIDC token exchange and configure the runner with temporary AWS credentials.</li>
    </ol>
            <p>This ensures your CI/CD jobs run with the <strong>principle of least privilege</strong>, only having the exact permissions they need, for the exact time they need them.</p>
        </section>
    </main>
</div>
